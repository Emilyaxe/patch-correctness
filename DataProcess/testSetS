{"Lang44b_Patch21":["1","Lang-44","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n+                    if((val.length()) != (1))\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n"],"Lang44b_Patch150":["0","Lang-44","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                    if (((dec == null) && (exp == null))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n"],"Math90b_Patch206":["1","Math-90","    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     * @throws ClassCastException if <code>v</code> is not Comparable\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n+if (!(v instanceof Comparable<?>)){throw new ClassCastException();}\n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n"],"Time4b_Patch80":["0","Time-4","    /**\n     * Always returns 1.\n     * \n     * @return the minimum value of 1\n     */\n    public int getMinimumValue(ReadablePartial instant, int[] values) {\n-        return 1;\n+        return (getWrappedField().getMaximumValue()) + 1;\n    }\n"],"Time4b_Patch81":["0","Time-4","    /**\n     * Get the maximum value for the field, which is one more than the wrapped\n     * field's maximum value.\n     * \n     * @return the maximum value\n     */\n    public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        if (true)\n+            return 0;\n        return getWrappedField().getMaximumValue(instant, values) + 1;\n    }\n"],"Time4b_Patch180":["0","Time-4","    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n+            if (((20) - (value + newTypes.length) < value) || ((2) != (org.joda.time.Partial.this.iTypes.length))) {\n            newValues[i] = value;\n+            }\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n"],"Math93b_Patch207":["1","Math-93","    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n     * </ul>\n     * </p>\n     * \n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n+ \tif (n<(int)20.0){return patch_method(n);}        \n+\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n"],"Math49b_Patch165":["0","Math-49","    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n+            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) {\n            entries.remove(index);\n        }\n    }\n+    }\n"],"Lang39b_Patch193":["0","Lang-39","    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n+  if (replaceIndex==0.0){return \"cbc\";}\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"],"Lang39b_Patch20":["0","Lang-39","    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n+        if(repeat)\n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"],"Math84b_Patch68":["0","Math-84","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n                return;\n-            }\n\n        }\n\n    }\n"],"Math84b_Patch69":["0","Math-84","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            if (true)\n+                return ;\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"Math40b_Patch161":["0","Math-40","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                    if (((signChangeIndex - start) >= (end - signChangeIndex)) || (xA <= org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"Math40b_Patch38":["0","Math-40","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n+                    if (true) {\n                        ++start;\n                    } else {\n-                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n-\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"Math40b_Patch37":["0","Math-40","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n+                signChangeIndex++;\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"Math41b_Patch162":["0","Math-41","    /**\n     * Returns the weighted arithmetic mean of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n     * <p>\n     * See {@link Mean} for details on the computing algorithm. The two-pass algorithm\n     * described above is used here, with weights applied in computing both the original\n     * estimate and the correction factor.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the mean of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final int begin, final int length) {\n        if (test(values, weights, begin, length)) {\n            Sum sum = new Sum();\n\n            // Compute initial estimate using definitional formula\n            double sumw = sum.evaluate(weights,begin,length);\n            double xbarw = sum.evaluate(values, weights, begin, length) / sumw;\n\n            // Compute correction factor in second pass\n            double correction = 0;\n            for (int i = begin; i < begin + length; i++) {\n                correction += weights[i] * (values[i] - xbarw);\n            }\n+            if (xbarw < length) {\n            return xbarw + (correction/sumw);\n        }\n+        }\n        return Double.NaN;\n    }\n"],"Math85b_Patch204":["1","Math-85","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+ \tif (fa * fb >= 0.0 &&!(fa * fb==0.0)) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"Math85b_Patch72":["0","Math-85","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n+        if(((fa * fb)) != (lowerBound))\n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"Math85b_PatchHDRepair9":["0","Math-85","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa / fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"Math85b_Patch174":["0","Math-85","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (maximumIterations == initial) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"Math42b_Patch163":["0","Math-42","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n+            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) {\n            columnsToDrop.add(col);\n          }\n        }\n+        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"Lang35b_Patch192":["0","Lang-35","    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n+     \tif (element == null){throw new IllegalArgumentException();}\n        return newArray;\n    }\n"],"Math87b_Patch175":["0","Math-87","    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected double[][] createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        List<LinearConstraint> constraints = getNormalizedConstraints();\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        double[][] matrix = new double[height][width];\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix[0][0] = -1;\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n            matrix[zIndex][width - 1] =\n                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n\n                if (!restrictToNonNegative) {\n                    matrix[zIndex][getSlackVariableOffset() - 1] =\n                        getInvertedCoeffiecientSum(objectiveCoefficients);\n                }\n\n                // initialize the constraint rows\n                int slackVar = 0;\n                int artificialVar = 0;\n                for (int i = 0; i < constraints.size(); i++) {\n                    LinearConstraint constraint = constraints.get(i);\n                    int row = getNumObjectiveFunctions() + i;\n\n                    // decision variable coefficients\n                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n\n                    // x-\n                    if (!restrictToNonNegative) {\n+                        if ((1) != (constraints.size())) {\n                        matrix[row][getSlackVariableOffset() - 1] =\n                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n                    }\n+                    }\n\n                    // RHS\n                    matrix[row][width - 1] = constraint.getValue();\n\n                    // slack variables\n                    if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n                    }\n\n                    // artificial variables\n                    if ((constraint.getRelationship() == Relationship.EQ) ||\n                        (constraint.getRelationship() == Relationship.GEQ)) {\n                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n                    }\n                }\n\n                return matrix;\n    }\n"],"Math87b_Patch73":["0","Math-87","    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected double[][] createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        List<LinearConstraint> constraints = getNormalizedConstraints();\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        double[][] matrix = new double[height][width];\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix[0][0] = -1;\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n            matrix[zIndex][width - 1] =\n                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n\n                if (!restrictToNonNegative) {\n                    matrix[zIndex][getSlackVariableOffset() - 1] =\n                        getInvertedCoeffiecientSum(objectiveCoefficients);\n                }\n\n                // initialize the constraint rows\n                int slackVar = 0;\n                int artificialVar = 0;\n                for (int i = 0; i < constraints.size(); i++) {\n                    LinearConstraint constraint = constraints.get(i);\n                    int row = getNumObjectiveFunctions() + i;\n\n                    // decision variable coefficients\n                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n\n                    // x-\n                    if (!restrictToNonNegative) {\n+                        if((1) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables))\n                        matrix[row][getSlackVariableOffset() - 1] =\n                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n                    }\n\n                    // RHS\n                    matrix[row][width - 1] = constraint.getValue();\n\n                    // slack variables\n                    if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n                    }\n\n                    // artificial variables\n                    if ((constraint.getRelationship() == Relationship.EQ) ||\n                        (constraint.getRelationship() == Relationship.GEQ)) {\n                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n                    }\n                }\n\n                return matrix;\n    }\n"],"Math88b_Patch176":["0","Math-88","    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n+                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n+        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"],"Math89b_Patch205":["1","Math-89","    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n     *         or is not comparable with previous entries\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n+if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}\n            addValue((Comparable<?>) v);            \n    }\n"],"Lang53b_Patch24":["0","Lang-53","    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n+            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds))))\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n"],"Lang53b_Patch152":["0","Lang-53","    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n+            if (org.apache.commons.lang.time.DateUtils.RANGE_WEEK_CENTER == millisecs) {\n            val.setTime(date);\n        }\n+        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n"],"Chart3b_Patch4":["0","Chart-3","    /**\r\n     * Age items in the series.  Ensure that the timespan from the youngest to\r\n     * the oldest record in the series does not exceed maximumItemAge time\r\n     * periods.  Oldest items will be removed if required.\r\n     *\r\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\r\n     *                sent to registered listeners IF any items are removed.\r\n     */\r\n    public void removeAgedItems(boolean notify) {\r\n        // check if there are any values earlier than specified by the history\r\n        // count...\r\n        if (getItemCount() > 1) {\r\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\r\n            boolean removed = false;\r\n            while ((latest - getTimePeriod(0).getSerialIndex())\r\n                    > this.maximumItemAge) {\r\n                this.data.remove(0);\r\n                removed = true;\r\n            }\r\n-            if (removed) {\r\n+            if(org.jfree.data.time.TimeSeries.this.data!=null) {\r\n                findBoundsByIteration();\r\n                if (notify) {\r\n                    fireSeriesChanged();\r\n                }\r\n            }\r\n        }\r\n    }\r\n"],"Math8b_Patch30":["0","Math-8","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n-        }\n\n        return out;\n\n    }\n"],"Math5b_Patch196":["1","Math-5","    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n+if (this.equals(new Complex(0,0))){return INF;}\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n"],"Math5b_Patch29":["1","Math-5","    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return org.apache.commons.math3.complex.Complex.INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n"],"Lang55b_Patch25":["1","Lang-55","    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n+            if(-1 == org.apache.commons.lang.time.StopWatch.this.stopTime)\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }\n"],"Chart5b_Patch7":["1","Chart-5","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\r\n+            if (!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)) {\r\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"Chart5b_Patch6":["0","Chart-5","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\r\n-                this.data.add(-index - 1, new XYDataItem(x, y));\r\n-            }\r\n-            else {\r\n-                this.data.add(new XYDataItem(x, y));\r\n+            if (false) {\r\n+                    this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x , y));\r\n+            } else {\r\n+                    this.data.add(new org.jfree.data.xy.XYDataItem(x , y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"Chart5b_Patch5":["0","Chart-5","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n            if (this.autoSort) {\r\n-                this.data.add(-index - 1, new XYDataItem(x, y));\r\n+                this.data.add(new org.jfree.data.xy.XYDataItem(x , y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"Lang51b_Patch23":["0","Lang-51","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n-                if (ch == 'Y') {\n+                if (str!=null) {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"Chart1b_Patch2":["0","Chart-1","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n-            return result;\r\n-        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"Chart1b_Patch1":["0","Chart-1","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n-            return result;\r\n-        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"Chart7b_Patch8":["0","Chart-7","    /**\r\n     * Returns the index of the time period with the maximum middle \r\n     * milliseconds.\r\n     * \r\n     * @return The index.\r\n     */\r\n    public int getMaxMiddleIndex() {\r\n-        return this.maxMiddleIndex;\r\n+        return this.maxEndIndex;\r\n    }\r\n"],"Math58b_Patch49":["0","Math-58","    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedResidualJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = FastMath.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n+            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm)\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }\n"],"Math58b_Patch168":["0","Math-58","        /**\n         * Validates parameters to ensure they are appropriate for the evaluation of\n         * the {@link #value(double,double[])} and {@link #gradient(double,double[])}\n         * methods.\n         *\n         * @param param Values of norm, mean and standard deviation.\n         * @throws NullArgumentException if {@code param} is {@code null}.\n         * @throws DimensionMismatchException if the size of {@code param} is\n         * not 3.\n         * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n         */\n        private void validateParameters(double[] param) {\n            if (param == null) {\n                throw new NullArgumentException();\n            }\n            if (param.length != 3) {\n                throw new DimensionMismatchException(param.length, 3);\n            }\n+            if ((param[2]) == 0) {\n            if (param[2] <= 0) {\n                throw new NotStrictlyPositiveException(param[2]);\n            }\n+         }\n        }\n"],"Math50b_Patch45":["1","Math-50","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"Math50b_Patch46":["1","Math-50","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n+                    if(!((x == 1) || ((1 < x) && (inverted))))\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"Math50b_PatchHDRepair5":["0","Math-50","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * ((int)x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"Math50b_Patch166":["0","Math-50","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n+                if ((((atol) != (org.apache.commons.math.analysis.solvers.BaseSecantSolver.DEFAULT_ABSOLUTE_ACCURACY)) && (org.apache.commons.math.analysis.solvers.BaseSecantSolver.this.method!=null)) || (f0 <= atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n+    }\n"],"Math95b_Patch76":["0","Math-95","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n+        if (true)\n+            return 0d;\n        return ret;\n    }\n"],"Math95b_Patch75":["0","Math-95","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n-        return ret;\n+        return numeratorDegreesOfFreedom;\n    }\n"],"Math53b_PatchHDRepair6":["0","Math-53","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n-        return createComplex(real + rhs.getReal(),\n+        return createComplex(real + rhs.getArgument(),\n            imaginary + rhs.getImaginary());\n    }\n"],"Math53b_Patch47":["1","Math-53","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n+        if ((isNaN) || (rhs.isNaN)) {\n+            return org.apache.commons.math.complex.Complex.NaN;\n+        } \n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"Math97b_Patch208":["0","Math-97","    /**\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function \n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     */\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n-        if (sign >= 0) {\n+  if (sign >= 0&&!(sign<=(double)0.546842)) {\n+\n            // check if either value is close to a zero\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }\n"],"Math3b_Patch194":["1","Math-3","    /**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            // Revert to scalar multiplication.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n+ \tif (len==1.0){return a[0] * b[0];}\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n"],"Math99b_Patch209":["1","Math-99","    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n     * <code>0</code>.</li>\n     * </ul>\n     * \n     * @param u any number\n     * @param v any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n+ \tif (u==Integer.MIN_VALUE){throw new ArithmeticException();}\n+ \tif (v==Integer.MIN_VALUE){throw new ArithmeticException();}\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n"],"Math4b_Patch195":["1","Math-4","    /** Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     */\n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n\n+if (v1D == null){return null;}\n        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n"],"Math57b_Patch48":["0","Math-57","    /** {@inheritDoc} */\n    @Override\n    public boolean equals(final Object other) {\n        if (!(other instanceof EuclideanIntegerPoint)) {\n            return false;\n        }\n        final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\n        if (point.length != otherPoint.length) {\n            return false;\n        }\n        for (int i = 0; i < point.length; i++) {\n            if (point[i] != otherPoint[i]) {\n+                if((1) != (org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.this.point.length))\n                return false;\n            }\n        }\n        return true;\n    }\n"],"Math57b_Patch167":["0","Math-57","    /** {@inheritDoc} */\n    @Override\n    public boolean equals(final Object other) {\n        if (!(other instanceof EuclideanIntegerPoint)) {\n            return false;\n        }\n        final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\n        if (point.length != otherPoint.length) {\n            return false;\n        }\n        for (int i = 0; i < point.length; i++) {\n+            if (((otherPoint[i])) != (otherPoint.length)) {\n            if (point[i] != otherPoint[i]) {\n                return false;\n            }\n        }\n+        }\n        return true;\n    }\n"],"Math2b_Patch27":["0","Math-2","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n+                tmp = mu + (k * sigma);\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"Math2b_Patch28":["0","Math-2","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"Math2b_Patch154":["0","Math-2","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n+                if (tmp == -1) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n+        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"Math70b_PatchHDRepair7":["1","Math-70","    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n    }\n"],"Math71b_Patch53":["0","Math-71","    /**\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     */\n    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n+            } else if ((dx > 0.0) || (org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE.length() < x1)) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n"],"Chart25b_Patch17":["0","Chart-25","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n+        if(0 == -1)\r\n        if (orientation == PlotOrientation.HORIZONTAL) {\r\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \r\n                    rangeAxis, statData, row, column);\r\n        }\r\n        else if (orientation == PlotOrientation.VERTICAL) {\r\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \r\n                    statData, row, column);\r\n        }\r\n    }\r\n"],"Chart25b_Patch15":["0","Chart-25","    /**\r\n     * Adds a mean and standard deviation to the table.\r\n     *\r\n     * @param mean  the mean.\r\n     * @param standardDeviation  the standard deviation.\r\n     * @param rowKey  the row key.\r\n     * @param columnKey  the column key.\r\n     */\r\n    public void add(Number mean, Number standardDeviation,\r\n                    Comparable rowKey, Comparable columnKey) {\r\n        MeanAndStandardDeviation item = new MeanAndStandardDeviation(\r\n                mean, standardDeviation);\r\n-        this.data.addObject(item, rowKey, columnKey);\r\n        double m = 0.0;\r\n        double sd = 0.0;\r\n        if (mean != null) {\r\n            m = mean.doubleValue();\r\n        }\r\n        if (standardDeviation != null) {\r\n            sd = standardDeviation.doubleValue();   \r\n        }\r\n        \r\n        if (!Double.isNaN(m)) {\r\n            if (Double.isNaN(this.maximumRangeValue) \r\n                    || m > this.maximumRangeValue) {\r\n                this.maximumRangeValue = m;\r\n            }\r\n        }\r\n        \r\n        if (!Double.isNaN(m + sd)) {\r\n            if (Double.isNaN(this.maximumRangeValueIncStdDev) \r\n                    || (m + sd) > this.maximumRangeValueIncStdDev) {\r\n                this.maximumRangeValueIncStdDev = m + sd;\r\n            }\r\n        }\r\n\r\n        if (!Double.isNaN(m)) {\r\n            if (Double.isNaN(this.minimumRangeValue) \r\n                    || m < this.minimumRangeValue) {\r\n                this.minimumRangeValue = m;\r\n            }\r\n        }\r\n\r\n        if (!Double.isNaN(m - sd)) {\r\n            if (Double.isNaN(this.minimumRangeValueIncStdDev) \r\n                    || (m - sd) < this.minimumRangeValueIncStdDev) {\r\n                this.minimumRangeValueIncStdDev = m - sd;\r\n            }\r\n        }\r\n\r\n        fireDatasetChanged();\r\n    }\r\n"],"Chart25b_Patch16":["0","Chart-25","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n+        if (true)\r\n+            return ;\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n        if (orientation == PlotOrientation.HORIZONTAL) {\r\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \r\n                    rangeAxis, statData, row, column);\r\n        }\r\n        else if (orientation == PlotOrientation.VERTICAL) {\r\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \r\n                    statData, row, column);\r\n        }\r\n    }\r\n"],"Chart25b_Patch92":["0","Chart-25","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n+        if (0 == 1) {\r\n        if (orientation == PlotOrientation.HORIZONTAL) {\r\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \r\n                    rangeAxis, statData, row, column);\r\n        }\r\n        else if (orientation == PlotOrientation.VERTICAL) {\r\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \r\n                    statData, row, column);\r\n        }\r\n    }\r\n+    }\r\n"],"Chart26b_Patch93":["0","Chart-26","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n-        if (b1 || b2) {\r\n+        if (org.jfree.chart.plot.CategoryPlot.DEFAULT_CROSSHAIR_STROKE!=null) {\r\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"Chart26b_Patch18":["0","Chart-26","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n        if (b1 || b2) {\r\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n+            if (true)\r\n+                return ;\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"Chart26b_Patch19":["0","Chart-26","    /**\r\n     * Adds an axis to the collection.\r\n     * \r\n     * @param axis  the axis (<code>null</code> not permitted).\r\n     * @param edge  the edge of the plot that the axis should be drawn on \r\n     *              (<code>null</code> not permitted).\r\n     */\r\n    public void add(Axis axis, RectangleEdge edge) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");   \r\n        }\r\n        if (edge == null) {\r\n            throw new IllegalArgumentException(\"Null 'edge' argument.\");   \r\n        }\r\n+        if(-1 == org.jfree.chart.axis.AxisCollection.this.axesAtLeft.size())\r\n        if (edge == RectangleEdge.TOP) {\r\n            this.axesAtTop.add(axis);\r\n        }\r\n        else if (edge == RectangleEdge.BOTTOM) {\r\n            this.axesAtBottom.add(axis);\r\n        }\r\n        else if (edge == RectangleEdge.LEFT) {\r\n            this.axesAtLeft.add(axis);\r\n        }\r\n        else if (edge == RectangleEdge.RIGHT) {\r\n            this.axesAtRight.add(axis);\r\n        }\r\n    }\r\n"],"Math25b_Patch197":["1","Math-25","        /**\n         * Estimate a first guess of the amplitude and angular frequency.\n         * This method assumes that the {@link #sortObservations()} method\n         * has been called previously.\n         *\n         * @throws ZeroException if the abscissa range is zero.\n         * @throws MathIllegalStateException when the guessing procedure cannot\n         * produce sensible results.\n         */\n        private void guessAOmega() {\n            // initialize the sums for the linear model between the two integrals\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n                // considering a linear model for f (and therefore constant f')\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            // compute the amplitude and pulsation coefficients\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                // Range of the observations, assuming that the\n                // observations are sorted.\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n                    // procedure cannot produce sensible results.\n\n                a = FastMath.sqrt(c1 / c2);\n+ \tif (c2==0.0){throw new MathIllegalStateException();}\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n"],"Math69b_Patch169":["0","Math-69","    /**\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n              outMatrix.setEntry(i, j, corr);\n+              if (2 < nVars) {\n              outMatrix.setEntry(j, i, corr);\n            }\n+            }\n            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }\n"],"Math28b_Patch198":["0","Math-28","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n-        } else if (minRatioPositions.size() > 1) {\n+  } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"Math28b_Patch158":["0","Math-28","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n+                if (minRatioPositions.isEmpty()) {\n                return minRow;\n        }\n+        }\n        return minRatioPositions.get(0);\n    }\n"],"Math28b_Patch32":["0","Math-28","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"Math28b_Patch33":["0","Math-28","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (true) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"Chart21b_Patch14":["0","Chart-21","    /**\r\n     * Tests this object for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object to test against (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (!(obj instanceof Range)) {\r\n            return false;\r\n        }\r\n        Range range = (Range) obj;\r\n        if (!(this.lower == range.lower)) {\r\n+            if(((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)) && ((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)))\r\n            return false;\r\n        }\r\n        if (!(this.upper == range.upper)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n"],"Chart21b_Patch91":["0","Chart-21","    /**\r\n     * Tests this object for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object to test against (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (!(obj instanceof Range)) {\r\n            return false;\r\n        }\r\n        Range range = (Range) obj;\r\n        if (!(this.lower == range.lower)) {\r\n+            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) {\r\n            return false;\r\n        }\r\n+        }\r\n        if (!(this.upper == range.upper)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n"],"Lang58b_Patch26":["1","Lang-58","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n+                    if(-1 < expPos)\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"Lang58b_Patch153":["0","Lang-58","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                    if (((dec == null) && (exp == null))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"Math24b_Patch157":["0","Math-24","    /**\n     * Adds functions.\n     *\n     * @param f List of functions.\n     * @return a function that computes the sum of the functions.\n     */\n    public static UnivariateFunction add(final UnivariateFunction ... f) {\n        return new UnivariateFunction() {\n            /** {@inheritDoc} */\n            public double value(double x) {\n                double r = f[0].value(x);\n                for (int i = 1; i < f.length; i++) {\n+                    if ((0 < r) || (!(-1 <= r))) {\n                    r += f[i].value(x);\n                }\n+                }\n                return r;\n            }\n        };\n    }\n"],"Time18b_Patch186":["0","Time-18","    /**\n     * Gets the milliseconds for a date at midnight.\n     * \n     * @param year  the year\n     * @param monthOfYear  the month\n     * @param dayOfMonth  the day\n     * @return the milliseconds\n     */\n    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n+        if ((!(10 == monthOfYear)) && (((31) - (2)) != (dayOfMonth))) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        }\n        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    }\n"],"Time15b_Patch210":["1","Time-15","    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n+if (val1==Long.MIN_VALUE){throw new ArithmeticException();}\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n"],"Time16b_Patch185":["0","Time-16","    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n+                if (resetFields) {\n                return computeMillis(resetFields, text);\n            }\n        }\n+        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iOffset != null) {\n            millis -= iOffset;\n        } else if (iZone != null) {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n"],"Time14b_Patch184":["0","Time-14","    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        if ((!(((fieldIndex) != (1)) && (valueToAdd <= values.length))) || (valueToAdd < -1)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n"],"Math80b_Patch172":["0","Math-80","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n+                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null) {\n                    work[i + k] = work[j - k];\n+                    }\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"Math80b_Patch59":["0","Math-80","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"Math81b_Patch62":["0","Math-81","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n-                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"Math81b_Patch63":["0","Math-81","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n+                if (true)\n+                    return ;\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"Math81b_Patch64":["0","Math-81","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n+                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin))\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"Math81b_Patch202":["0","Math-81","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+  if (end - start > 2&&!(end - start>=(double)0.0)) {\n+\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"Math81b_Patch173":["0","Math-81","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n-            if (dMin1 == dN1 && dMin2 == dN2) {\n+            if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"Time11b_Patch84":["0","Time-11","    /**\n     * Processes all the rules and builds a DateTimeZone.\n     *\n     * @param id  time zone id to assign\n     * @param outputID  true if the zone id should be output\n     */\n    public DateTimeZone toDateTimeZone(String id, boolean outputID) {\n        if (id == null) {\n            throw new IllegalArgumentException();\n        }\n\n        // Discover where all the transitions occur and store the results in\n        // these lists.\n        ArrayList<Transition> transitions = new ArrayList<Transition>();\n\n        // Tail zone picks up remaining transitions in the form of an endless\n        // DST cycle.\n        DSTZone tailZone = null;\n\n        long millis = Long.MIN_VALUE;\n        int saveMillis = 0;\n            \n        int ruleSetCount = iRuleSets.size();\n        for (int i=0; i<ruleSetCount; i++) {\n            RuleSet rs = iRuleSets.get(i);\n            Transition next = rs.firstTransition(millis);\n            if (next == null) {\n                continue;\n            }\n            addTransition(transitions, next);\n            millis = next.getMillis();\n            saveMillis = next.getSaveMillis();\n\n            // Copy it since we're going to destroy it.\n            rs = new RuleSet(rs);\n\n            while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n                if (addTransition(transitions, next)) {\n                    if (tailZone != null) {\n                        // Got the extra transition before DSTZone.\n                        break;\n                    }\n                }\n                millis = next.getMillis();\n                saveMillis = next.getSaveMillis();\n                if (tailZone == null && i == ruleSetCount - 1) {\n+                    if(!((ruleSetCount <= 1) && ((tailZone!=null) || (outputID))))\n                    tailZone = rs.buildTailZone(id);\n                    // If tailZone is not null, don't break out of main loop until\n                    // at least one more transition is calculated. This ensures a\n                    // correct 'seam' to the DSTZone.\n                }\n            }\n\n            millis = rs.getUpperLimit(saveMillis);\n        }\n\n        // Check if a simpler zone implementation can be returned.\n        if (transitions.size() == 0) {\n            if (tailZone != null) {\n                // This shouldn't happen, but handle just in case.\n                return tailZone;\n            }\n            return buildFixedZone(id, \"UTC\", 0, 0);\n        }\n        if (transitions.size() == 1 && tailZone == null) {\n            Transition tr = transitions.get(0);\n            return buildFixedZone(id, tr.getNameKey(),\n                                  tr.getWallOffset(), tr.getStandardOffset());\n        }\n\n        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n        if (zone.isCachable()) {\n            return CachedDateTimeZone.forZone(zone);\n        }\n        return zone;\n    }\n"],"Time11b_Patch82":["0","Time-11","        /**\n         * Factory to create instance from builder.\n         * \n         * @param id  the zone id\n         * @param outputID  true if the zone id should be output\n         * @param transitions  the list of Transition objects\n         * @param tailZone  optional zone for getting info beyond precalculated tables\n         */\n        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,\n                                        DSTZone tailZone) {\n            int size = transitions.size();\n            if (size == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            long[] trans = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n\n            Transition last = null;\n            for (int i=0; i<size; i++) {\n                Transition tr = transitions.get(i);\n\n                if (!tr.isTransitionFrom(last)) {\n                    throw new IllegalArgumentException(id);\n                }\n\n                trans[i] = tr.getMillis();\n                wallOffsets[i] = tr.getWallOffset();\n                standardOffsets[i] = tr.getStandardOffset();\n                nameKeys[i] = tr.getNameKey();\n\n                last = tr;\n            }\n\n            // Some timezones (Australia) have the same name key for\n            // summer and winter which messes everything up. Fix it here.\n            String[] zoneNameData = new String[5];\n            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n            for (int j = 0; j < zoneStrings.length; j++) {\n                String[] set = zoneStrings[j];\n                if (set != null && set.length == 5 && id.equals(set[0])) {\n                    zoneNameData = set;\n                }\n            }\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n\n            for (int i = 0; i < nameKeys.length - 1; i++) {\n                String curNameKey = nameKeys[i];\n                String nextNameKey = nameKeys[i + 1];\n                long curOffset = wallOffsets[i];\n                long nextOffset = wallOffsets[i + 1];\n                long curStdOffset = standardOffsets[i];\n                long nextStdOffset = standardOffsets[i + 1];\n                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n                if (curOffset != nextOffset &&\n                        curStdOffset == nextStdOffset &&\n                        curNameKey.equals(nextNameKey) &&\n                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&\n                        curNameKey.equals(zoneNameData[2]) &&\n                        curNameKey.equals(zoneNameData[4])) {\n                    \n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                        System.out.println(\"     - \" + new DateTime(trans[i], chrono) +\n                                           \" - \" + new DateTime(trans[i + 1], chrono));\n                    }\n                    if (curOffset > nextOffset) {\n                        nameKeys[i] = (curNameKey + \"-Summer\").intern();\n                    } else if (curOffset < nextOffset) {\n                        nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n                        i++;\n                    }\n                }\n            }\n\n            if (tailZone != null) {\n                if (tailZone.iStartRecurrence.getNameKey()\n                    .equals(tailZone.iEndRecurrence.getNameKey())) {\n-                    if (ZoneInfoCompiler.verbose()) {\n-                        System.out.println(\"Fixing duplicate recurrent name key - \" +\n-                                           tailZone.iStartRecurrence.getNameKey());\n-                    }\n                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence.renameAppend(\"-Summer\"),\n                            tailZone.iEndRecurrence);\n                    } else {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence,\n                            tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n                    }\n                }\n            }\n            \n            return new PrecalculatedZone\n                ((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }\n"],"Math105b_Patch177":["0","Math-105","    /**\n     * Adds the observation (x,y) to the regression data set.\n     * <p>\n     * Uses updating formulas for means and sums of squares defined in \n     * \"Algorithms for Computing the Sample Variance: Analysis and\n     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985\n     *\n     *\n     * @param x independent variable value\n     * @param y dependent variable value\n     */\n    public void addData(double x, double y) {\n        if (n == 0) {\n            xbar = x;\n+            if (y <= x) {\n            ybar = y;\n+            }\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n            xbar += dx / (double) (n + 1.0);\n            ybar += dy / (double) (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n    }\n"],"Math105b_Patch79":["0","Math-105","    /**\n     * Adds the observation (x,y) to the regression data set.\n     * <p>\n     * Uses updating formulas for means and sums of squares defined in \n     * \"Algorithms for Computing the Sample Variance: Analysis and\n     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985\n     *\n     *\n     * @param x independent variable value\n     * @param y dependent variable value\n     */\n    public void addData(double x, double y) {\n        if (n == 0) {\n            xbar = x;\n+            if((org.apache.commons.math.stat.regression.SimpleRegression.this.xbar <= 1) || ((y < x) && (y < x)))\n            ybar = y;\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n            xbar += dx / (double) (n + 1.0);\n            ybar += dy / (double) (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n    }\n"],"Math104b_Patch78":["0","Math-104","    /**\n     * Returns the regularized gamma function P(a, x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n     * Regularized Gamma Function</a>, equation (1).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n     * Incomplete Gamma Function</a>, equation (4).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n     * </li>\n     * </ul>\n     * \n     * @param a the a parameter.\n     * @param x the value.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete. \n     * @return the regularized gamma function P(a, x)\n     * @throws MathException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaP(double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (((a == 1) || ((a >= 1.0) && (x > a))) && (org.apache.commons.math.special.Gamma.HALF_LOG_2_PI <= x)) {\n            // use regularizedGammaQ because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n        } else {\n            // calculate series\n            double n = 0.0; // current element index\n            double an = 1.0 / a; // n-th element in the series\n            double sum = an; // partial sum\n            while (Math.abs(an) > epsilon && n < maxIterations) {\n                // compute next element in the series\n                n = n + 1.0;\n                an = an * (x / (a + n));\n\n                // update partial sum\n                sum = sum + an;\n            }\n            if (n >= maxIterations) {\n                throw new MaxIterationsExceededException(maxIterations);\n            } else {\n                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n            }\n        }\n\n        return ret;\n    }\n"],"Math82b_PatchHDRepair8":["0","Math-82","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio <= minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"Math82b_Patch65":["0","Math-82","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"Math82b_Patch67":["0","Math-82","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+                if((0) != (minValue))\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"Math82b_Patch203":["1","Math-82","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+ \tif (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n+\n        }\n        return minRatioPos;\n    }\n"],"Chart13b_Patch11":["0","Chart-13","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n        if (this.leftBlock != null) {\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth()),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n-        if (this.rightBlock != null) {\r\n+        if (null != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"Chart13b_Patch10":["0","Chart-13","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\r\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n-                    new Range(0.0, constraint.getWidth()),\r\n-                    LengthConstraintType.RANGE, h[2], null,\r\n-                    LengthConstraintType.FIXED);\r\n-            Size2D size = this.leftBlock.arrange(g2, c3);\r\n-            w[2] = size.width;\r\n-        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"Chart13b_Patch89":["0","Chart-13","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n        if (this.leftBlock != null) {\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth()),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n+        if (null!=null) {\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n+        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"Chart14b_Patch188":["1","Chart-14","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n+ \tif (markers == null){return false;}\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"Chart15b_Patch12":["0","Chart-15","    /**\r\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\r\n     * printer).\r\n     * <P>\r\n     * This method is the focus of the entire JFreeChart library.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param chartArea  the area within which the chart should be drawn.\r\n     * @param anchor  the anchor point (in Java2D space) for the chart \r\n     *                (<code>null</code> permitted).\r\n     * @param info  records info about the drawing (null means collect no info).\r\n     */\r\n    public void draw(Graphics2D g2, \r\n                     Rectangle2D chartArea, Point2D anchor, \r\n                     ChartRenderingInfo info) {\r\n\r\n        notifyListeners(new ChartProgressEvent(this, this, \r\n                ChartProgressEvent.DRAWING_STARTED, 0));\r\n\r\n        // record the chart area, if info is requested...\r\n        if (info != null) {\r\n            info.clear();\r\n            info.setChartArea(chartArea);\r\n        }\r\n\r\n        // ensure no drawing occurs outside chart area...\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(chartArea);\r\n\r\n        g2.addRenderingHints(this.renderingHints);\r\n\r\n        // draw the chart background...\r\n        if (this.backgroundPaint != null) {\r\n            g2.setPaint(this.backgroundPaint);\r\n            g2.fill(chartArea);\r\n        }\r\n\r\n        if (this.backgroundImage != null) {\r\n            Composite originalComposite = g2.getComposite();\r\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                    this.backgroundImageAlpha));\r\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \r\n                    this.backgroundImage.getWidth(null), \r\n                    this.backgroundImage.getHeight(null));\r\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\r\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \r\n                    (int) dest.getY(), (int) dest.getWidth(), \r\n                    (int) dest.getHeight(), null);\r\n            g2.setComposite(originalComposite);\r\n        }\r\n\r\n        if (isBorderVisible()) {\r\n            Paint paint = getBorderPaint();\r\n            Stroke stroke = getBorderStroke();\r\n            if (paint != null && stroke != null) {\r\n                Rectangle2D borderArea = new Rectangle2D.Double(\r\n                        chartArea.getX(), chartArea.getY(), \r\n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \r\n                        - 1.0);\r\n                g2.setPaint(paint);\r\n                g2.setStroke(stroke);\r\n                g2.draw(borderArea);\r\n            }\r\n        }\r\n\r\n        // draw the title and subtitles...\r\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\r\n        nonTitleArea.setRect(chartArea);\r\n        this.padding.trim(nonTitleArea);\r\n        \r\n        EntityCollection entities = null;\r\n        if (info != null) {\r\n            entities = info.getEntityCollection();   \r\n        }\r\n        if (this.title != null) {\r\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \r\n                    (entities != null));\r\n            if (e != null) {\r\n                entities.addAll(e);   \r\n            }\r\n        }\r\n\r\n        Iterator iterator = this.subtitles.iterator();\r\n        while (iterator.hasNext()) {\r\n            Title currentTitle = (Title) iterator.next();\r\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \r\n                    (entities != null));\r\n            if (e != null) {\r\n                entities.addAll(e);   \r\n            }\r\n        }\r\n\r\n        Rectangle2D plotArea = nonTitleArea;\r\n \r\n        // draw the plot (axes and data visualisation)\r\n        PlotRenderingInfo plotInfo = null;\r\n        if (info != null) {\r\n            plotInfo = info.getPlotInfo();\r\n        }\r\n-        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\r\n+        fireChartChanged();\r\n\r\n        g2.setClip(savedClip);\r\n\r\n        notifyListeners(new ChartProgressEvent(this, this, \r\n                ChartProgressEvent.DRAWING_FINISHED, 100));\r\n    }\r\n"],"Chart15b_Patch13":["0","Chart-15","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).  This method is called by the \r\n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \r\n     * to call it yourself.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the area within which the plot should be drawn.\r\n     * @param anchor  the anchor point.\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param info  collects info about the drawing \r\n     *              (<code>null</code> permitted).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo info) {\r\n\r\n        // adjust for insets...\r\n+        if (true)\r\n+            return ;\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(plotArea);\r\n\r\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\r\n        if (info != null) {\r\n            info.setPlotArea(plotArea);\r\n            info.setDataArea(plotArea);\r\n        }\r\n\r\n        drawBackground(g2, plotArea);\r\n\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(plotArea);\r\n\r\n        // adjust the plot area by the interior spacing value\r\n        double gapPercent = getInteriorGap();\r\n        double labelPercent = 0.0;\r\n        if (getLabelGenerator() != null) {\r\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \r\n        }\r\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \r\n                + labelPercent) * 2.0;\r\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\r\n\r\n        if (DEBUG_DRAW_INTERIOR) {\r\n            double hGap = plotArea.getWidth() * getInteriorGap();\r\n            double vGap = plotArea.getHeight() * getInteriorGap();\r\n            double igx1 = plotArea.getX() + hGap;\r\n            double igx2 = plotArea.getMaxX() - hGap;\r\n            double igy1 = plotArea.getY() + vGap;\r\n            double igy2 = plotArea.getMaxY() - vGap;\r\n            g2.setPaint(Color.lightGray);\r\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \r\n                    igy2 - igy1));\r\n        }\r\n\r\n        double linkX = plotArea.getX() + gapHorizontal / 2;\r\n        double linkY = plotArea.getY() + gapVertical / 2;\r\n        double linkW = plotArea.getWidth() - gapHorizontal;\r\n        double linkH = plotArea.getHeight() - gapVertical;\r\n        \r\n        // make the link area a square if the pie chart is to be circular...\r\n        if (isCircular()) { // is circular?\r\n            double min = Math.min(linkW, linkH) / 2;\r\n            linkX = (linkX + linkX + linkW) / 2 - min;\r\n            linkY = (linkY + linkY + linkH) / 2 - min;\r\n            linkW = 2 * min;\r\n            linkH = 2 * min;\r\n        }\r\n        \r\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\r\n\r\n        // the link area defines the dog leg points for the linking lines to \r\n        // the labels\r\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH * (1 - this.depthFactor));\r\n        state.setLinkArea(linkAreaXX);\r\n\r\n        if (DEBUG_DRAW_LINK_AREA) {\r\n            g2.setPaint(Color.blue);\r\n            g2.draw(linkAreaXX);\r\n            g2.setPaint(Color.yellow);\r\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \r\n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\r\n        }\r\n        \r\n        // the explode area defines the max circle/ellipse for the exploded pie \r\n        // sections.\r\n        // it is defined by shrinking the linkArea by the linkMargin factor.\r\n        double hh = linkW * getLabelLinkMargin();\r\n        double vv = linkH * getLabelLinkMargin();\r\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \r\n                linkY + vv / 2.0, linkW - hh, linkH - vv);\r\n       \r\n        state.setExplodedPieArea(explodeArea);\r\n        \r\n        // the pie area defines the circle/ellipse for regular pie sections.\r\n        // it is defined by shrinking the explodeArea by the explodeMargin \r\n        // factor. \r\n        double maximumExplodePercent = getMaximumExplodePercent();\r\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\r\n        \r\n        double h1 = explodeArea.getWidth() * percent;\r\n        double v1 = explodeArea.getHeight() * percent;\r\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \r\n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\r\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\r\n\r\n        // the link area defines the dog-leg point for the linking lines to \r\n        // the labels\r\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\r\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH - depth);\r\n        state.setLinkArea(linkArea);   \r\n\r\n        state.setPieArea(pieArea);\r\n        state.setPieCenterX(pieArea.getCenterX());\r\n        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\r\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\r\n        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\r\n\r\n        // get the data source - return if null;\r\n        PieDataset dataset = getDataset();\r\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\r\n            drawNoDataMessage(g2, plotArea);\r\n            g2.setClip(savedClip);\r\n            drawOutline(g2, plotArea);\r\n            return;\r\n        }\r\n\r\n        // if too any elements\r\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\r\n            String text = \"Too many elements\";\r\n            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\r\n            g2.setFont(sfont);\r\n            FontMetrics fm = g2.getFontMetrics(sfont);\r\n            int stringWidth = fm.stringWidth(text);\r\n\r\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \r\n                    - stringWidth) / 2), (int) (plotArea.getY() \r\n                    + (plotArea.getHeight() / 2)));\r\n            return;\r\n        }\r\n        // if we are drawing a perfect circle, we need to readjust the top left\r\n        // coordinates of the drawing area for the arcs to arrive at this\r\n        // effect.\r\n        if (isCircular()) {\r\n            double min = Math.min(plotArea.getWidth(), \r\n                    plotArea.getHeight()) / 2;\r\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \r\n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\r\n        }\r\n        // get a list of keys...\r\n        List sectionKeys = dataset.getKeys();\r\n\r\n        if (sectionKeys.size() == 0) {\r\n            return;\r\n        }\r\n\r\n        // establish the coordinates of the top left corner of the drawing area\r\n        double arcX = pieArea.getX();\r\n        double arcY = pieArea.getY();\r\n\r\n        //g2.clip(clipArea);\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                getForegroundAlpha()));\r\n\r\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\r\n        double runningTotal = 0;\r\n        if (depth < 0) {\r\n            return;  // if depth is negative don't draw anything\r\n        }\r\n\r\n        ArrayList arcList = new ArrayList();\r\n        Arc2D.Double arc;\r\n        Paint paint;\r\n        Paint outlinePaint;\r\n        Stroke outlineStroke;\r\n\r\n        Iterator iterator = sectionKeys.iterator();\r\n        while (iterator.hasNext()) {\r\n\r\n            Comparable currentKey = (Comparable) iterator.next();\r\n            Number dataValue = dataset.getValue(currentKey);\r\n            if (dataValue == null) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double value = dataValue.doubleValue();\r\n            if (value <= 0) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double startAngle = getStartAngle();\r\n            double direction = getDirection().getFactor();\r\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \r\n                    / totalValue;\r\n            double angle2 = startAngle + (direction * (runningTotal + value) \r\n                    * 360) / totalValue;\r\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\r\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \r\n                        pieArea.getWidth(), pieArea.getHeight() - depth,\r\n                        angle1, angle2 - angle1, Arc2D.PIE));\r\n            }\r\n            else {\r\n                arcList.add(null);\r\n            }\r\n            runningTotal += value;\r\n        }\r\n\r\n        Shape oldClip = g2.getClip();\r\n\r\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \r\n                pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \r\n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \r\n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \r\n                - top.getCenterY());\r\n\r\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \r\n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\r\n\r\n        Area a = new Area(top);\r\n        a.add(new Area(lower));\r\n        Area b = new Area(bottom);\r\n        b.add(new Area(upper));\r\n        Area pie = new Area(a);\r\n        pie.intersect(b);\r\n\r\n        Area front = new Area(pie);\r\n        front.subtract(new Area(top));\r\n\r\n        Area back = new Area(pie);\r\n        back.subtract(new Area(bottom));\r\n\r\n        // draw the bottom circle\r\n        int[] xs;\r\n        int[] ys;\r\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \r\n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\r\n\r\n        int categoryCount = arcList.size();\r\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \r\n                 categoryIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            Comparable key = getSectionKey(categoryIndex);\r\n            paint = lookupSectionPaint(key, true);\r\n            outlinePaint = lookupSectionOutlinePaint(key);\r\n            outlineStroke = lookupSectionOutlineStroke(key);\r\n            g2.setPaint(paint);\r\n            g2.fill(arc);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(arc);\r\n            g2.setPaint(paint);\r\n\r\n            Point2D p1 = arc.getStartPoint();\r\n\r\n            // draw the height\r\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\r\n                    (int) p1.getX(), (int) p1.getX()};\r\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \r\n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\r\n            Polygon polygon = new Polygon(xs, ys, 4);\r\n            g2.setPaint(java.awt.Color.lightGray);\r\n            g2.fill(polygon);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(polygon);\r\n            g2.setPaint(paint);\r\n\r\n        }\r\n\r\n        g2.setPaint(Color.gray);\r\n        g2.fill(back);\r\n        g2.fill(front);\r\n\r\n        // cycle through once drawing only the sides at the back...\r\n        int cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key, true);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, false, true);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        // cycle through again drawing only the sides at the front...\r\n        cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, true, false);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        g2.setClip(oldClip);\r\n\r\n        // draw the sections at the top of the pie (and set up tooltips)...\r\n        Arc2D upperArc;\r\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \r\n                 sectionIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\r\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \r\n                    arc.getAngleExtent(), Arc2D.PIE);\r\n            \r\n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\r\n            paint = lookupSectionPaint(currentKey, true);\r\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\r\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\r\n            g2.setPaint(paint);\r\n            g2.fill(upperArc);\r\n            g2.setStroke(outlineStroke);\r\n            g2.setPaint(outlinePaint);\r\n            g2.draw(upperArc);\r\n\r\n           // add a tooltip for the section...\r\n            if (info != null) {\r\n                EntityCollection entities \r\n                        = info.getOwner().getEntityCollection();\r\n                if (entities != null) {\r\n                    String tip = null;\r\n                    PieToolTipGenerator tipster = getToolTipGenerator();\r\n                    if (tipster != null) {\r\n                        // @mgs: using the method's return value was missing \r\n                        tip = tipster.generateToolTip(dataset, currentKey);\r\n                    }\r\n                    String url = null;\r\n                    if (getURLGenerator() != null) {\r\n                        url = getURLGenerator().generateURL(dataset, currentKey,\r\n                                getPieIndex());\r\n                    }\r\n                    PieSectionEntity entity = new PieSectionEntity(\r\n                            upperArc, dataset, getPieIndex(), sectionIndex, \r\n                            currentKey, tip, url);\r\n                    entities.add(entity);\r\n                }\r\n            }\r\n            List keys = dataset.getKeys();\r\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\r\n                    originalPlotArea.getX(), originalPlotArea.getY(), \r\n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \r\n                    - depth);\r\n            if (getSimpleLabels()) {\r\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \r\n                        linkArea, state);\r\n            }\r\n            else {\r\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \r\n                        state);\r\n            }\r\n        }\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n        drawOutline(g2, originalPlotArea);\r\n\r\n    }\r\n"],"Chart17b_Patch90":["0","Chart-17","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     * \r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end) \r\n        throws CloneNotSupportedException {\r\n\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n        if (end < start) {\r\n+            if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.this.range.length()) {\r\n            throw new IllegalArgumentException(\"Requires start <= end.\");\r\n        }\r\n+        }\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item \r\n                    = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"Time19b_Patch187":["0","Time-19","    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n-        } else if (offsetLocal > 0) {\n+        } else if (org.joda.time.DateTimeZone.this.iID!=null) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n"],"Time19b_PatchHDRepair10":["1","Time-19","    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n"],"Chart19b_Patch189":["1","Chart-19","    /**\r\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\r\n     * is not assigned to the plot.\r\n     * \r\n     * @param axis  the axis (<code>null</code> not permitted).\r\n     * \r\n     * @return The axis index.\r\n     * \r\n     * @see #getDomainAxis(int)\r\n     * @see #getRangeAxisIndex(ValueAxis)\r\n     * \r\n     * @since 1.0.3\r\n     */\r\n    public int getDomainAxisIndex(CategoryAxis axis) {\r\n+ \tif (axis == null){throw new IllegalArgumentException();}\n        return this.domainAxes.indexOf(axis);\r\n    }\r\n"],"Math39b_Patch160":["0","Math-39","  /** Initialize the integration step.\n   * @param forward forward integration indicator\n   * @param order order of the method\n   * @param scale scaling vector for the state vector (can be shorter than state vector)\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param yDot0 first time derivative of y0\n   * @param y1 work array for a state vector\n   * @param yDot1 work array for the first time derivative of y1\n   * @return first integration step\n   */\n  public double initializeStep(final boolean forward, final int order, final double[] scale,\n                               final double t0, final double[] y0, final double[] yDot0,\n                               final double[] y1, final double[] yDot1) {\n\n    if (initialStep > 0) {\n      // use the user provided value\n      return forward ? initialStep : -initialStep;\n    }\n\n    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n    // this guess will be used to perform an Euler step\n    double ratio;\n    double yOnScale2 = 0;\n    double yDotOnScale2 = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = y0[j] / scale[j];\n      yOnScale2    += ratio * ratio;\n      ratio         = yDot0[j] / scale[j];\n+      if ((scale.length) != (org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.this.maxStep)) {\n      yDotOnScale2 += ratio * ratio;\n    }\n+    }\n\n    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n               1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\n    if (! forward) {\n      h = -h;\n    }\n\n    // perform an Euler step using the preceding rough guess\n    for (int j = 0; j < y0.length; ++j) {\n      y1[j] = y0[j] + h * yDot0[j];\n    }\n    computeDerivatives(t0 + h, y1, yDot1);\n\n    // estimate the second derivative of the solution\n    double yDDotOnScale = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n      yDDotOnScale += ratio * ratio;\n    }\n    yDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\n\n    // step size is computed such that\n    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n    final double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\n    final double h1 = (maxInv2 < 1.0e-15) ?\n                      FastMath.max(1.0e-6, 0.001 * FastMath.abs(h)) :\n                      FastMath.pow(0.01 / maxInv2, 1.0 / order);\n    h = FastMath.min(100.0 * FastMath.abs(h), h1);\n    h = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\n    if (h < getMinStep()) {\n      h = getMinStep();\n    }\n    if (h > getMaxStep()) {\n      h = getMaxStep();\n    }\n    if (! forward) {\n      h = -h;\n    }\n\n    return h;\n\n  }\n"],"Math73b_Patch54":["0","Math-73","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n-\n+        return solve(f, min, max);\n    }\n"],"Math73b_Patch55":["0","Math-73","    /**\n     * Verifies that <code>lower < initial < upper</code>\n     * throws IllegalArgumentException if not\n     *\n     * @param lower  lower endpoint\n     * @param initial initial value\n     * @param upper upper endpoint\n     * @throws IllegalArgumentException\n     */\n    protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        if (((!((1) != (lower))) && (org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result < org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.defaultFunctionValueAccuracy)) || (initial <= lower)) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n                    lower, initial, upper);\n        }\n    }\n"],"Math73b_Patch201":["0","Math-73","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n+  if (initial>(double)0.0){throw new IllegalArgumentException();}\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n"],"Lang24b_Patch191":["1","Lang-24","    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n+ \tif (hasDecPoint==true){return false;}\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n"],"Math32b_Patch34":["0","Math-32","    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n-                // the instance covers the whole space\n-                setSize(Double.POSITIVE_INFINITY);\n-                setBarycenter(Vector2D.NaN);\n+        if (false) {\n+\t\tsetSize(java.lang.Double.POSITIVE_INFINITY);\n+\t\tsetBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN);\n            } else {\n                setSize(0);\n-                setBarycenter(new Vector2D(0, 0));\n+\t\tsetBarycenter(new org.apache.commons.math3.geometry.euclidean.twod.Vector2D(0 , 0));\n            }\n+\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n"],"Math33b_Patch159":["0","Math-33","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) {\n                columnsToDrop.add(i);\n            }\n        }\n+        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"Math33b_Patch36":["0","Math-33","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                if((org.apache.commons.math3.optimization.linear.SimplexTableau.NEGATIVE_VAR_COLUMN_LABEL.length()) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables))\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"Math34b_PatchHDRepair4":["1","Math-34","    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n    }\n"],"Math78b_Patch171":["0","Math-78","    /**\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     */\n    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n-                if (x0 == x2) {\n+                if (((1 < x2) && (!(y0 <= i))) || (x0 == x2)) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n"],"Math78b_Patch58":["0","Math-78","    /**\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     */\n    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n+                    if(-1 <= delta)\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n"],"Math35b_Patch199":["1","Math-35","    /**\n     * Creates a new ElitisticListPopulation instance.\n     *\n     * @param chromosomes list of chromosomes in the population\n     * @param populationLimit maximal size of the population\n     * @param elitismRate how many best chromosomes will be directly transferred to the\n     *                    next generation [in %]\n     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n     */\n    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                   final int populationLimit,\n                                   final double elitismRate) {\n        super(chromosomes, populationLimit);\n        this.elitismRate = elitismRate;\n+ \tif (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}\n+ \tif (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}\n    }\n"]}