{"patch1-Lang-9-SimFix-plausible.patch":["0","    /**\n     * Creates an EventListenerSupport object which supports the provided\n     * listener interface using the specified class loader to create the JDK\n     * dynamic proxy.\n     *\n     * @param listenerInterface the listener interface.\n     * @param classLoader       the class loader.\n     *\n     * @throws NullPointerException if <code>listenerInterface</code> or\n     *         <code>classLoader</code> is <code>null</code>.\n     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n     *         not an interface.\n     */\n    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n        this();\n        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                listenerInterface.getName());\n+        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0);\n        initializeTransientFields(listenerInterface, classLoader);\n    }\n"],"patch1-Lang-7-Arja-plausible.patch":["0","    /**\n     * Creates an EventListenerSupport object which supports the provided\n     * listener interface using the specified class loader to create the JDK\n     * dynamic proxy.\n     *\n     * @param listenerInterface the listener interface.\n     * @param classLoader       the class loader.\n     *\n     * @throws NullPointerException if <code>listenerInterface</code> or\n     *         <code>classLoader</code> is <code>null</code>.\n     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n     *         not an interface.\n     */\n    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n        this();\n        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                listenerInterface.getName());\n        initializeTransientFields(listenerInterface, classLoader);\n    }\n"],"patch1-Lang-7-RSRepair-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n-            return null;\n+            return Short.parseShort(str);\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-7-jKali.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n-            return null;\n+\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-7-GenProg-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n-            return null;\n+            Double d = createDouble(str);\n+            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-1-SimFix-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n+            if(hexDigits>16){\n+                try{\n+                    return createLong(str);\n+                }catch (final NumberFormatException nfe) {\n+}\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n"],"patch2-Lang-6-SequenceR.patch":["0","    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos+=Character.charCount(Character.codePointAt(input,0));\n            }\n        }\n    }\n"],"patch1-Closure-30-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-33-Arja-plausible.patch":["0","  /** Determines if typeA is a subtype of typeB */\n  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n        if (typeA.isPropertyTypeDeclared(property)) {\n          if (!propA.isEquivalentTo(propB)) {\n            return false;\n          }\n        } else {\n          if (!propA.isSubtype(propB)) {\n-            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-33-Jaid-plausible.patch":["0","  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n+    \tif((isNativeObjectType() == constraintObj.isRecordType()) == true){\r\n+    \t\treturn;\r\n+    \t\t}\r\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n"],"patch1-Closure-33-Kali-plausible.patch":["0","  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n+        if (false) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n"],"patch1-Closure-33-RSRepair-plausible.patch":["0","  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n-          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n"],"patch2-Closure-33-Jaid-plausible.patch":["0","  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n+          if((propType.isBooleanValueType() || typeToInfer.isStringValueType()) == true){\r\n+        \t  return;\r\n+        \t  }\r\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n"],"patch1-Math-49-jKali-plausible.patch":["0","    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n-        if (!isDefaultValue(value)) {\n+        if (true) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n"],"patch1-Math-49-Nopol-plausible.patch":["0","    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n        }\n    }\n"],"patch1-Math-49-DynaMoth-plausible.patch":["0","    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n        }\n    }\n"],"patch1-Math-49-AVATAR-plausible.patch":["0","    /**\n     * Builds a message string by from a pattern and its arguments.\n     * @param locale Locale in which the message should be translated\n     * @param pattern format specifier\n     * @param arguments format arguments\n     * @return a message string\n     * @since 2.2\n     */\n    private static String buildMessage(final Locale locale, final Localizable pattern,\n                                       final Object ... arguments) {\n-        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);\n    }\n"],"patch1-Math-49-kPAR-plausible.patch":["0","    /**\n     * Builds a message string by from a pattern and its arguments.\n     * @param locale Locale in which the message should be translated\n     * @param pattern format specifier\n     * @param arguments format arguments\n     * @return a message string\n     * @since 2.2\n     */\n    private static String buildMessage(final Locale locale, final Localizable pattern,\n                                       final Object ... arguments) {\n-        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);\n    }\n"],"patch1-Math-49-Kali-plausible.patch":["0","    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n-        if (!isDefaultValue(value)) {\n+        if (true) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n"],"patch1-Closure-31-RSRepair-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        return null;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-31-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-38-SequenceR.patch":["0","  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if(prev=='-'){\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n"],"patch3-Closure-38-SequenceR.patch":["0","  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if((prev<0)||(prev=='-')){\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n"],"patch1-Closure-38-SimFix-plausible.patch":["0","  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n"],"patch2-Closure-38-SequenceR.patch":["0","  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if((prev!=0)&&(prev=='-')){\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n"],"patch1-Closure-35-kPAR-plausible.patch":["0","  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      ObjectType objType = ObjectType.cast(type.collapseUnion());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }\n"],"patch1-Closure-36-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-40-kPAR-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"patch1-Math-40-Arja-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n-                        // we have more points after sign change, drop the highest point\n+                        ++start;\n+                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"patch1-Math-40-GenProg-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n-            }\n+            } else {\n+                signChangeIndex = 2;\n+                if (nbPoints == x.length) {\n+                    nbPoints--;\n+                    if (signChangeIndex >= (x.length + 1) / 2) {\n+                        System.arraycopy(x, 1, x, 0, nbPoints);\n+                        System.arraycopy(y, 1, y, 0, nbPoints);\n+                        --signChangeIndex;\n+                    }\n+                }\n+            }\n\n-            // insert the last computed point\n+            yB = nextY;\n+            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n+            if (agingB >= MAXIMAL_AGING) {\n+                targetY = -REDUCTION_FACTOR * yA;\n+            } else {\n+                targetY = 0;\n+            }\n+            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"patch1-Math-40-RSRepair-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n-                    // the guessed root is either not strictly inside the interval or it\n+                    signChangeIndex = 2;\n+                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n"],"patch1-Math-41-Nopol-plausible.patch":["0","    /**\n     * Returns the weighted arithmetic mean of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n     * <p>\n     * See {@link Mean} for details on the computing algorithm. The two-pass algorithm\n     * described above is used here, with weights applied in computing both the original\n     * estimate and the correction factor.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the mean of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final int begin, final int length) {\n        if (test(values, weights, begin, length)) {\n            Sum sum = new Sum();\n\n            // Compute initial estimate using definitional formula\n            double sumw = sum.evaluate(weights,begin,length);\n            double xbarw = sum.evaluate(values, weights, begin, length) / sumw;\n\n            // Compute correction factor in second pass\n            double correction = 0;\n            for (int i = begin; i < begin + length; i++) {\n                correction += weights[i] * (values[i] - xbarw);\n            }\n-            return xbarw + (correction/sumw);\n+            if (xbarw < length) {\n+                return xbarw + (correction/sumw);\n+            }\n        }\n        return Double.NaN;\n    }\n"],"patch1-Math-41-DynaMoth-plausible.patch":["0","    /**\n     * <p>Returns the weighted variance of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre>\n     * where weightedMean is the weighted mean</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the weighted variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final int begin, final int length) {\n\n        double var = Double.NaN;\n\n-        if (test(values, weights,begin, length)) {\n-            clear();\n-            if (length == 1) {\n-                var = 0.0;\n-            } else if (length > 1) {\n-                Mean mean = new Mean();\n-                double m = mean.evaluate(values, weights, begin, length);\n-                var = evaluate(values, weights, m, begin, length);\n+        if (values[0] <= length) {\n+            if (test(values, weights,begin, length)) {\n+                clear();\n+                if (length == 1) {\n+                    var = 0.0;\n+                } else if (length > 1) {\n+                    Mean mean = new Mean();\n+                    double m = mean.evaluate(values, weights, begin, length);\n+                    var = evaluate(values, weights, m, begin, length);\n+                }\n            }\n        }\n        return var;\n    }\n"],"patch1-Math-42-Nopol-plausible.patch":["0","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n-            columnsToDrop.add(col);\n+            if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) {\n+                columnsToDrop.add(col);\n+            }\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"patch1-Math-42-kPAR-plausible.patch":["0","    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected RealMatrix createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n+            maximize ? f.getConstantTerm() : -1 * f.hashCode());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        // initialize the constraint rows\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            // decision variable coefficients\n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            // x-\n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            // RHS\n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            // slack variables\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n            }\n\n            // artificial variables\n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }\n"],"patch1-Math-43-SimFix-plausible.patch":["0","    /**\n     * <p>\n     * Sets the implementation for the geometric mean.\n     * </p>\n     * <p>\n     * This method must be activated before any data has been added - i.e.,\n     * before {@link #addValue(double) addValue} has been used to add data;\n     * otherwise an IllegalStateException will be thrown.\n     * </p>\n     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n     *        computing the geometric mean\n     * @throws IllegalStateException if data has already been added (i.e if n >\n     *         0)\n     * @since 1.2\n     */\n    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+        this.sumImpl=geoMeanImpl;\n        checkEmpty();\n        this.geoMeanImpl = geoMeanImpl;\n    }\n"],"patch1-Math-43-kPAR-plausible.patch":["0","    /**\n     * Add a value to the data\n     * @param value the value to add\n     */\n    public void addValue(double value) {\n        sumImpl.increment(value);\n        sumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        // If mean, variance or geomean have been overridden,\n        // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) {\n            meanImpl.increment(value);\n        }\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n    }\n"],"patch1-Math-44-SimFix-plausible.patch":["0","    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws ConvergenceException {\n\n            forward = interpolator.isForward();\n+            t0=interpolator.getPreviousTime();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (FastMath.abs(dt) < convergence) {\n                // we cannot do anything on such a small step, don't trigger any events\n                return false;\n            }\n            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h = dt / n;\n\n            final UnivariateRealFunction f = new UnivariateRealFunction() {\n                public double value(final double t) {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, interpolator.getInterpolatedState());\n                }\n            };\n\n            double ta = t0;\n            double ga = g0;\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    // find the event time making sure we select a solution just at or past the exact root\n                    final double root;\n                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n                        @SuppressWarnings(\"unchecked\")\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n                        root = forward ?\n                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                    } else {\n                        final double baseRoot = forward ?\n                                                solver.solve(maxIterationCount, f, ta, tb) :\n                                                solver.solve(maxIterationCount, f, tb, ta);\n                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                        root = forward ?\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                    }\n\n                    if ((!Double.isNaN(previousEventTime)) &&\n                        (FastMath.abs(root - ta) <= convergence) &&\n                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event,\n                        // retry the substep excluding this value\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                        --i;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        // no sign change: there is no event for now\n                        ta = tb;\n                        ga = gb;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n    }\n"],"patch1-Math-7-kPAR-plausible.patch":["0","    /** {@inheritDoc} */\n    public void addEventHandler(final EventHandler handler,\n                                final double maxCheckInterval,\n                                final double convergence,\n                                final int maxIterationCount) {\n-        addEventHandler(handler, maxCheckInterval, convergence,\n+        addEventHandler(handler, maxIterationCount, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n"],"patch1-Math-7-Nopol-plausible.patch":["0","    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) {\n+                        handler.handleStep(interpolator, isLastStep);\n+                    }\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n"],"patch1-Math-8-SimFix-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n-        for (int i = 0; i < sampleSize; i++) {\n+        for(int i=sampleSize;i<sampleSize;i++){\n            out[i] = sample();\n        }\n\n        return out;\n\n    }\n"],"patch1-Math-8-jGenProg-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n+\n        }\n\n        return out;\n\n    }\n"],"patch1-Math-8-kPAR-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }\n"],"patch1-Math-8-DynaMoth-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n+        if (false) {\n+            for (int i = 0; i < sampleSize; i++) {\n+                out[i] = sample();\n+            }\n        }\n\n        return out;\n\n    }\n"],"patch1-Math-8-jKali-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n-        }\n+\n+\n+\n\n        return out;\n\n    }\n"],"patch1-Math-8-TBar-plausible.patch":["0","    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n-        for (int i = 0; i < sampleSize; i++) {\n+        for (int i = 0; i==sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }\n"],"patch2-Math-5-CapGen-plausible.patch":["0","    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if object is\n     * {@code null}, not an instance of Complex, or not equal to this Complex\n     * instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (this.add(org.apache.commons.math3.complex.Complex.I).isNaN) {\n                return isNaN;\n            } else {\n                return (real == c.real) && (imaginary == c.imaginary);\n            }\n        }\n        return false;\n    }\n"],"patch3-Math-5-CapGen-plausible.patch":["0","    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if object is\n     * {@code null}, not an instance of Complex, or not equal to this Complex\n     * instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) {\n                return isNaN;\n            } else {\n                return (real == c.real) && (imaginary == c.imaginary);\n            }\n        }\n        return false;\n    }\n"],"patch1-Math-5-Cardumen-plausible.patch":["0","    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if object is\n     * {@code null}, not an instance of Complex, or not equal to this Complex\n     * instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n-        if (this == other) {\n+        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex)other;\n            if (c.isNaN) {\n                return isNaN;\n            } else {\n                return (real == c.real) && (imaginary == c.imaginary);\n            }\n        }\n        return false;\n    }\n"],"patch1-Math-5-CapGen-plausible.patch":["0","    /**\n     * Test for the equality of two Complex objects.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * All {@code NaN} values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to {@code Double.NaN}, the complex number is equal to\n     * {@code NaN}.\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if object is\n     * {@code null}, not an instance of Complex, or not equal to this Complex\n     * instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) {\n                return isNaN;\n            } else {\n                return (real == c.real) && (imaginary == c.imaginary);\n            }\n        }\n        return false;\n    }\n"],"patch1-Math-6-SimFix-plausible.patch":["0","    /**\n     * Gets the number of iterations performed by the algorithm.\n     * The number iterations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     */\n    public int getIterations() {\n-        return iterations.getCount();\n+        return evaluations.getCount();\n    }\n"],"patch1-Math-6-AVATAR-plausible.patch":["0","    /**\n     * Gets the number of iterations performed by the algorithm.\n     * The number iterations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     */\n    public int getIterations() {\n-        return iterations.getCount();\n+        return this.evaluations.getCount();\n    }\n"],"patch1-Math-6-TBar-plausible.patch":["0","    /**\n     * Gets the number of iterations performed by the algorithm.\n     * The number iterations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     */\n    public int getIterations() {\n-        return iterations.getCount();\n+        return this.evaluations.getCount();\n    }\n"],"patch1-Lang-10-kPAR-plausible.patch":["0","    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n+            if((Character.isWhitespace(c)) && !(unquote)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n"],"patch1-Lang-10-SimFix-plausible.patch":["0","    /**\n     * Creates an EventListenerSupport object which supports the provided\n     * listener interface using the specified class loader to create the JDK\n     * dynamic proxy.\n     *\n     * @param listenerInterface the listener interface.\n     * @param classLoader       the class loader.\n     *\n     * @throws NullPointerException if <code>listenerInterface</code> or\n     *         <code>classLoader</code> is <code>null</code>.\n     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n     *         not an interface.\n     */\n    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n        this();\n        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                listenerInterface.getName());\n+        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0);\n        initializeTransientFields(listenerInterface, classLoader);\n    }\n"],"patch1-Math-60-jGenProg-plausible.patch":["0","    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on equations 14-17 of:\n     * <ul>\n     * <li>\n     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n     *   Resource. <a target=\"_blank\"\n     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n     * </li>\n     * </ul>\n     * The recurrence relationship defined in those equations can result in\n     * very large intermediate results which can result in numerical overflow.\n     * As a means to combat these overflow conditions, the intermediate results\n     * are scaled whenever they threaten to become numerically unstable.</p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MathException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            boolean infinite = false;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                /*\n                 * Need to scale. Try successive powers of the larger of a or b\n                 * up to 5th power. Throw ConvergenceException if one or both\n                 * of p2, q2 still overflow.\n                 */\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(\n                            LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                             x);\n                }\n                infinite = true;\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n                    } else if (b != 0) {\n                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                    }\n                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n                    if (!infinite) {\n                        break;\n                    }\n                }\n            }\n\n            if (infinite) {\n               // Scaling failed\n               throw new ConvergenceException(\n                 LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                  x);\n            }\n\n            double r = p2 / q2;\n\n            if (Double.isNaN(r)) {\n-                throw new ConvergenceException(\n-                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                throw new MaxIterationsExceededException(maxIterations,\n+                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                  x);\n            }\n            relativeError = FastMath.abs(r / c - 1.0);\n\n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                x);\n        }\n\n        return c;\n    }\n"],"patch1-Math-58-RSRepair-plausible.patch":["0","    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedResidualJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n-            // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n-            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n-            } else if (fp < 0) {\n-                paru = FastMath.min(paru, lmPar);\n-            }\n+            } else {\n+                for (int j = rank; j < cols; ++j) {\n+                    lmDir[permutation[j]] = 0;\n+                }\n+                if (fp < 0) {\n+                    paru = FastMath.min(paru, lmPar);\n+                }\n+            }\n\n            // compute an improved estimate for lmPar\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }\n"],"patch1-Math-58-DynaMoth-plausible.patch":["0","    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedResidualJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n                }\n            }\n-            sum2 = 0;\n+            if (this.costRelativeTolerance != this.orthoTolerance) {\n+                sum2 = 0;\n+            }\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = FastMath.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }\n"],"patch1-Math-58-Nopol-plausible.patch":["0","    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedResidualJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) {\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+                }\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = FastMath.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }\n"],"patch1-Math-59-SequenceR.patch":["0","    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a;\n    }\n"],"patch1-Closure-45-Arja-plausible.patch":["0","  /**\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() { return a; }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured vairables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   */\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n-        return true;\n+        return false;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }\n"],"patch1-Closure-45-RSRepair-plausible.patch":["0","  /**\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() { return a; }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured vairables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   */\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n-        return true;\n+        return false;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }\n"],"patch1-Closure-45-jKali-plausible.patch":["0","  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n-            } else if (!NodeUtil.isLiteralValue(\n-                assign.assignNode.getLastChild(), true)) {\n+            } else if (true) {\n              assignedToUnknownValue = true;\n            }\n          }\n\n          if (assignedToUnknownValue && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n"],"patch1-Closure-45-AVATAR-plausible.patch":["0","  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n-            } else if (!NodeUtil.isLiteralValue(\n-                assign.assignNode.getLastChild(), true)) {\n-              assignedToUnknownValue = true;\n-            }\n+            } else assignedToUnknownValue = true;\n          }\n\n          if (assignedToUnknownValue && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n"],"patch1-Closure-45-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-48-AVATAR-plausible.patch":["0","    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+        valueType = ownerNode.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      // NOTE(nicksantos): Determining whether a property is declared or not\n      // is really really obnoxious.\n      //\n      // The problem is that there are two (equally valid) coding styles:\n      //\n      // (function() {\n      //   /* The authoritative definition of goog.bar. */\n      //   goog.bar = function() {};\n      // })();\n      //\n      // function f() {\n      //   goog.bar();\n      //   /* Reset goog.bar to a no-op. */\n      //   goog.bar = function() {};\n      // }\n      //\n      // In a dynamic language with first-class functions, it's very difficult\n      // to know which one the user intended without looking at lots of\n      // contextual information (the second example demonstrates a small case\n      // of this, but there are some really pathological cases as well).\n      //\n      // The current algorithm checks if either the declaration has\n      // jsdoc type information, or @const with a known type,\n      // or a function literal with a name we haven't seen before.\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n"],"patch1-Closure-49-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-46-Kali-plausible.patch":["0","  @Override\n  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (true) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n"],"patch1-Closure-46-kPAR-plausible.patch":["0","  @Override\n  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (!that.isNumberObjectType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n"],"patch1-Closure-46-SimFix-plausible.patch":["0","  @Override\n  public JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n-    return builder.build();\n+    return getLeastSupertype(this,that);\n  }\n"],"patch1-Closure-46-jKali-plausible.patch":["0","  @Override\n  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (true) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n"],"patch1-Closure-46-Arja-plausible.patch":["0","  @Override\n  public String toString() {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }\n"],"patch3-Math-50-Jaid-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n+                    \tif(!((f0 > x0 + x1) == true)){\r\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                    \t}\r\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-FixMiner-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-AVATAR-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-Arja.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n-                    // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-jMutRepair-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n-                    if (x == x1) {\n+                    if (x > x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-TBar-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-SimFix-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n-                    if (x == x1) {\n+                    if(x==x0){\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-Jaid-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n+                \tif((x == x1) == true){\r\n+                \t\tx1=x;\r\n+                \t\t}else{\r\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n+                \t\t}\r\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-kPAR-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-50-jGenProg-plausible.patch":["0","    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n+\n+                            f0 = computeObjectiveValue(x0);                             x0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));                             f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n"],"patch1-Math-52-jMutRepair-plausible.patch":["0","  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // preliminary computation\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n-  if (c == 0) {\n+  if (c <= 0) {\n    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n    // we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        // the (q1, q2, q3) vector is aligned with everything\n        // this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      // we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  // compute the vectorial part\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  // compute the scalar part\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n"],"patch2-Math-53-CapGen.patch":["0","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n+        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;}\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"patch2-Math-53-Jaid-plausible.patch":["0","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n+        if((rhs.isNaN() == isInfinite()) == false){\r\n+        \treturn this.NaN;\r\n+        \t}\r\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"patch1-Math-53-Jaid-plausible.patch":["0","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n+     \tif((isNaN() == rhs.isNaN()) == false){\r\n+    \t\treturn this.NaN;\r\n+    \t\t}\r\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"patch3-Math-53-Jaid-plausible.patch":["0","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n+        if((rhs.isNaN() || isInfinite()) == true){\r\n+        \treturn this.NaN;\r\n+\r\n+        \t}\r\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"patch2-Math-53-Jaid.patch":["0","    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n+        if((isNaN() || rhs.isNaN()) == true){\n+            return NaN;\n+        }\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n"],"patch1-Math-4-Nopol-plausible.patch":["0","    /** Get the intersection point of the instance and another line.\n     * @param other other line\n     * @return intersection point of the instance and the other line\n     * or null if there are no intersection points\n     */\n    public Vector2D intersection(final Line other) {\n        final double d = sin * other.cos - other.sin * cos;\n        if (FastMath.abs(d) < 1.0e-10) {\n-            return null;\n+            if (((other.sin < 1) && (other.sin < 1)) || ((org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset) != (d))) {\n+                return null;\n+            }\n        }\n        return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n                            (sin * other.originOffset - other.sin * originOffset) / d);\n    }\n"],"patch1-Math-4-ACS-plausible.patch":["0","    /** Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     */\n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n\n-        // check location of point with respect to first sub-line\n+if (v1D == null){return null;}        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n"],"patch1-Math-56-Arja-plausible.patch":["0","    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n-            ++idx;\n+            while (count < index) {\n+                count += idx;\n+                ++idx;\n+            }\n+            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n\n        return indices;\n    }\n"],"patch1-Math-1-SimFix-plausible.patch":["0","    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER - a valid epsilon value and\n     * the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator\n     * has no effect). OR - a valid maxDenominator value and the epsilon value\n     * set to zero (that way epsilon only has effect if there is an exact match\n     * before the maxDenominator value is reached).\n     * </p>\n     * <p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     * https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value\n     *            the double value to convert to a fraction.\n     * @param epsilon\n     *            maximum error allowed. The resulting fraction is within\n     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n     * @param maxDenominator\n     *            maximum denominator value allowed.\n     * @param maxIterations\n     *            maximum number of convergents.\n     * @throws FractionConversionException\n     *             if the continued fraction failed to converge.\n     */\n    private BigFraction(final double value, final double epsilon,\n                        final int maxDenominator, int maxIterations)\n        throws FractionConversionException {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long) FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            numerator = BigInteger.valueOf(a0);\n            denominator = BigInteger.ONE;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r1 = 1.0 / (r0 - a0);\n            final long a1 = (long) FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n-            if ((p2 > overflow) || (q2 > overflow)) {\n-                // in maxDenominator mode, if the last fraction was very close to the actual value\n-                // q2 may overflow in the next iteration; in this case return the last one.\n+            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            final double convergent = (double) p2 / (double) q2;\n            if ((n < maxIterations) &&\n                (FastMath.abs(convergent - value) > epsilon) &&\n                (q2 < maxDenominator)) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            numerator   = BigInteger.valueOf(p2);\n            denominator = BigInteger.valueOf(q2);\n        } else {\n            numerator   = BigInteger.valueOf(p1);\n            denominator = BigInteger.valueOf(q1);\n        }\n    }\n"],"patch1-Math-57-AVATAR-plausible.patch":["0","    /**\n     * Runs the K-means++ clustering algorithm.\n     *\n     * @param points the points to cluster\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm\n     *     for.  If negative, no maximum will be used\n     * @return a list of clusters containing the points\n     */\n    public List<Cluster<T>> cluster(final Collection<T> points,\n                                    final int k, final int maxIterations) {\n        // create the initial clusters\n        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n        assignPointsToClusters(clusters, points);\n\n        // iterate through updating the centers until we're done\n-        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n+        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations;\n        for (int count = 0; count < max; count++) {\n            boolean clusteringChanged = false;\n            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n            for (final Cluster<T> cluster : clusters) {\n                final T newCenter;\n                if (cluster.getPoints().isEmpty()) {\n                    switch (emptyStrategy) {\n                        case LARGEST_VARIANCE :\n                            newCenter = getPointFromLargestVarianceCluster(clusters);\n                            break;\n                        case LARGEST_POINTS_NUMBER :\n                            newCenter = getPointFromLargestNumberCluster(clusters);\n                            break;\n                        case FARTHEST_POINT :\n                            newCenter = getFarthestPoint(clusters);\n                            break;\n                        default :\n                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n                    }\n                    clusteringChanged = true;\n                } else {\n                    newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n                    if (!newCenter.equals(cluster.getCenter())) {\n                        clusteringChanged = true;\n                    }\n                }\n                newClusters.add(new Cluster<T>(newCenter));\n            }\n            if (!clusteringChanged) {\n                return clusters;\n            }\n            assignPointsToClusters(newClusters, points);\n            clusters = newClusters;\n        }\n        return clusters;\n    }\n"],"patch1-Math-57-jMutRepair-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    public boolean equals(final Object other) {\n        if (!(other instanceof EuclideanIntegerPoint)) {\n            return false;\n        }\n        final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\n        if (point.length != otherPoint.length) {\n            return false;\n        }\n        for (int i = 0; i < point.length; i++) {\n-            if (point[i] != otherPoint[i]) {\n+            if (this.point[i] != otherPoint[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n"],"patch1-Math-2-Kali-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (false) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-SOFix-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (tmp >= upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch2-Math-2-SOFix-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (tmp > upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-jMutRepair-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (tmp >= upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-kPAR-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt(serialVersionUID);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-jKali-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (false) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-Nopol-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n+            if (sigma == lower) {\n+                if (tmp < upper) {\n+                    upper = ((int) Math.ceil(tmp)) - 1;\n+                }\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-RSRepair-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-AVATAR-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt((1.0 - upper) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-Arja-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-GenProg-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n"],"patch1-Math-2-TBar-plausible.patch":["0","    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n-        final double m = getNumberOfSuccesses();\n-        final double n = getSampleSize();\n+        final int m = getNumberOfSuccesses();\n+        final int n = getSampleSize();\n        return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n    }\n"],"patch1-Lang-20-TBar-plausible.patch":["0","    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, {@code null} if null array input\n     * @since 2.0\n     */\n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder();\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n"],"patch1-Lang-20-Arja-plausible.patch":["0","    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, {@code null} if null array input\n     * @since 2.0\n     */\n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(256);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n"],"patch1-Lang-20-kPAR-plausible.patch":["0","    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, {@code null} if null array input\n     * @since 2.0\n     */\n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(noOfItems + 1);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n"],"patch1-Lang-20-AVATAR-plausible.patch":["0","    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, {@code null} if null array input\n     * @since 2.0\n     */\n    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int noOfItems = (endIndex - startIndex);\n        if (noOfItems <= 0) {\n            return EMPTY;\n        }\n        \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder((16) + 1);\n\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n"],"patch1-Lang-22-AVATAR-plausible.patch":["0","    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n"],"patch1-Lang-22-jMutRepair-plausible.patch":["0","    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n"],"patch1-Lang-22-TBar-plausible.patch":["0","    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u)==1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n"],"patch1-Lang-22-jKali-plausible.patch":["0","    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (false) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n"],"patch1-Lang-21-kPAR-plausible.patch":["0","    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n"],"patch1-Closure-109-kPAR-plausible.patch":["0","  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n  }\n"],"patch1-Closure-109-SimFix-plausible.patch":["0","  /**\n   * TypeName := NameExpression | NameExpression TypeApplication\n   * TypeApplication := '.<' TypeExpressionList '>'\n   */\n  private Node parseTypeName(JsDocToken token) {\n-    if (token != JsDocToken.STRING) {\n+    if(token==null){\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }\n"],"patch1-Closure-109-TBar-plausible.patch":["0","  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n  }\n"],"patch1-Closure-108-AVATAR-plausible.patch":["0","    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n-                v.getJSDocInfo())\n+                grandparent.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n"],"patch1-Closure-108-SimFix-plausible.patch":["0","  /**\n   * Overwrite all the source information in this node and its subtree with\n   * that of {@code other} iff the source info is missing.\n   */\n  public Node useSourceInfoIfMissingFromForTree(Node other) {\n    useSourceInfoIfMissingFrom(other);\n    for (Node child = getFirstChild();\n         child != null; child = child.getNext()) {\n      child.useSourceInfoIfMissingFromForTree(other);\n    }\n-\n+    this.propListHead=other.propListHead;\n    return this;\n  }\n"],"patch1-Closure-107-TBar-plausible.patch":["0","  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it. But shut off the i18n warnings,\n      // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n+      \n    }\n\n    return options;\n  }\n"],"patch1-Closure-107-SimFix-plausible.patch":["0","  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n-    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n-      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n-      // translations file, they might reasonably try to write their own\n-      // implementation of goog.getMsg that makes the substitution at\n-      // run-time.\n-      //\n-      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n-      // so we might as well inline it. But shut off the i18n warnings,\n-      // because the user didn't really ask for i18n.\n+    } else if(options.messageBundle!=null){\n      options.messageBundle = new EmptyMessageBundle();\n    }\n\n    return options;\n  }\n"],"patch8-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(0,'.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch4-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch3-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_INVALID_ARGUMENT_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch2-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NULL_ARGUMENT_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch9-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_BASE_CLASS_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch5-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_DUPLICATE_NAMESPACE_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch7-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_LATE_PROVIDE_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch6-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_TOO_MANY_ARGUMENTS_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch10-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(namespace,'.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch1-Closure-92-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf('.','.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch1-Closure-106-SimFix-plausible.patch":["0","  /**\n   * Extracts the top-level block comment from the JsDoc comment, if any.\n   * This method differs from the extractMultilineTextualBlock in that it\n   * terminates under different conditions (it doesn't have the same\n   * prechecks), it does not first read in the remaining of the current\n   * line and its conditions for ignoring the \"*\" (STAR) are different.\n   *\n   * @param token The starting token.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n+          jsdocBuilder.recordDescription(line);\n          token = next();\n      }\n    } while (true);\n  }\n"],"patch9-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_BASE_CLASS_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch5-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_DUPLICATE_NAMESPACE_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch2-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NULL_ARGUMENT_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch3-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_INVALID_ARGUMENT_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch8-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(0,'.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch4-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch1-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf('.','.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch6-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_TOO_MANY_ARGUMENTS_ERROR\");\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch10-Closure-93-SequenceR.patch":["0","    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(namespace,'.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n"],"patch1-Closure-101-jKali-plausible.patch":["0","  /**\n   * Add options that are safe. Safe means options that won't break the\n   * JavaScript code even if no symbols are exported and no coding convention\n   * is used.\n   * @param options The CompilerOptions object to set the options on.\n   */\n  private static void applySafeCompilationOptions(CompilerOptions options) {\n    // Does not call applyBasicCompilationOptions(options) because the call to\n    // skipAllCompilerPasses() cannot be easily undone.\n-        options.closurePass = true;\n+\n    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n    options.inlineLocalVariables = true;\n    options.checkGlobalThisLevel = CheckLevel.OFF;\n    options.foldConstants = true;\n    options.removeConstantExpressions = true;\n    options.coalesceVariableNames = true;\n    options.deadAssignmentElimination = true;\n    options.extractPrototypeMemberDeclarations = true;\n    options.collapseVariableDeclarations = true;\n    options.convertToDottedProperties = true;\n    options.labelRenaming = true;\n    options.removeDeadCode = true;\n    options.optimizeArgumentsArray = true;\n    options.removeUnusedVars = true;\n    options.removeUnusedVarsInGlobalScope = false;\n\n    // Allows annotations that are not standard.\n    options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n        CheckLevel.OFF);\n  }\n"],"patch1-Closure-12-TBar-plausible.patch":["0","      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+          if (apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n"],"patch1-Closure-12-Kali-plausible.patch":["0","    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,\n      // or anything that creates a new object.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n"],"patch1-Closure-12-AVATAR-plausible.patch":["0","      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+          if (apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n"],"patch1-Math-28-Arja-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n-                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-RSRepair-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n-                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-jMutRepair-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (row != tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-ACS-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n-        } else if (minRatioPositions.size() > 1) {\n+        } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-GenProg-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n-                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-Kali-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (true) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-28-jKali-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (true) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Closure-10-Kali-plausible.patch":["0","  /**\n   * Apply the supplied predicate against\n   * all possible result Nodes of the expression.\n   */\n  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return allResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return allResultsMatch(n.getFirstChild(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        {\n+            if (true)\n+                return true;\n+            return allResultsMatch(n.getFirstChild().getNext(), p)\n+                && allResultsMatch(n.getLastChild(), p);\n+        }\n      default:\n        return p.apply(n);\n    }\n  }\n"],"patch1-Closure-10-RSRepair-plausible.patch":["0","  /**\n   * Apply the supplied predicate against\n   * all possible result Nodes of the expression.\n   */\n  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return allResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return allResultsMatch(n.getFirstChild(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        int type = n.getType();\n      default:\n        return p.apply(n);\n    }\n  }\n"],"patch1-Closure-10-GenProg-plausible.patch":["0","  private void tryConvertToNumber(Node n) {\n    switch (n.getType()) {\n      case Token.NUMBER:\n        // Nothing to do\n        return;\n      case Token.AND:\n      case Token.OR:\n      case Token.COMMA:\n        tryConvertToNumber(n.getLastChild());\n        return;\n      case Token.HOOK:\n-        tryConvertToNumber(n.getChildAtIndex(1));\n+        ;\n        tryConvertToNumber(n.getLastChild());\n        return;\n      case Token.NAME:\n        if (!NodeUtil.isUndefined(n)) {\n          return;\n        }\n        break;\n    }\n\n    Double result = NodeUtil.getNumberValue(n);\n    if (result == null) {\n      return;\n    }\n\n    double value = result;\n\n    Node replacement = NodeUtil.numberNode(value, n);\n    if (replacement.isEquivalentTo(n)) {\n      return;\n    }\n\n    n.getParent().replaceChild(n, replacement);\n    reportCodeChange();\n  }\n"],"patch1-Closure-10-Arja-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        return null;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-29-jKali-plausible.patch":["0","    /**\n     * Create from an array, specifying zero tolerance.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n-            if (!isDefaultValue(value)) {\n+            if (true) {\n                entries.put(key, value);\n            }\n        }\n    }\n"],"patch1-Closure-15-Kali-plausible.patch":["0","    private boolean canInline() {\n\n      // Cannot inline a parameter.\n      if (defCfgNode.isFunction()) {\n        return false;\n      }\n\n      getDefinition(defCfgNode, null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,\n      // or anything that creates a new object.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&\n          defCfgNode.getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(defCfgNode),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n"],"patch1-Closure-14-SimFix-plausible.patch":["0","  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+              cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n"],"patch1-Closure-19-FixMiner-plausible.patch":["0","  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n        // \"this\" references aren't currently modeled in the CFG.\n\n      default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n+        \n    }\n  }\n"],"patch1-Closure-19-SimFix.patch":["0","  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    if (condition.isCall() && condition.getChildCount() == 2) {\n      Node callee = condition.getFirstChild();\n      Node param = condition.getLastChild();\n-      if (callee.isGetProp() && param.isQualifiedName()) {\n+      if (param.isName()||param.isGetProp()) {\n        JSType paramType =  getTypeIfRefinable(param, blindScope);\n        Node left = callee.getFirstChild();\n        Node right = callee.getLastChild();\n        if (left.isName() && \"goog\".equals(left.getString()) &&\n            right.isString()) {\n          Function<TypeRestriction, JSType> restricter =\n              restricters.get(right.getString());\n          if (restricter != null) {\n            return restrictParameter(param, paramType, blindScope, restricter,\n                outcome);\n          }\n        }\n      }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }\n"],"patch1-Lang-16-RSRepair-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                return createInteger(str);\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-16-SimFix-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n+        str=str.toLowerCase();\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-16-Arja-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                return createInteger(str);\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-16-kPAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n-        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Math-20-FixMiner-plausible.patch":["0","    /**\n     * Default constructor, uses default parameters\n     */\n    public CMAESOptimizer() {\n-        this(0);\n+        \n    }\n"],"patch1-Math-20-Nopol-plausible.patch":["0","    /**\n     * Update of the covariance matrix C.\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n     * current offspring.\n     * @param arz Unsorted matrix containing the gaussian random values of the\n     * current offspring.\n     * @param arindex Indices indicating the fitness-order of the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     */\n    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n            final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma); // mu difference vectors\n            RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n-            oldFac += 1. - ccov1 - ccovmu;\n+            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                oldFac += 1. - ccov1 - ccovmu;\n+            }\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);\n                double negminresidualvariance = 0.66;\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                double negalphaold = 0.5; // where to make up for the variance\n                                          // loss,\n                // prepare vectors, compute negative updating matrix Cneg\n                int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                int[] idxReverse = reverse(idxnorms);\n                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                int[] idxInv = inverse(idxnorms);\n                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                RealMatrix artmp = BD.multiply(arzneg);\n                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                        // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(\n                                // plus rank mu update\n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n"],"patch1-Math-20-DynaMoth-plausible.patch":["0","    /**\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     */\n    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n-            if (max(diagD) > 1e14 * min(diagD)) {\n+            if (this.dimension == 1) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }\n"],"patch1-Lang-18-TBar-plausible.patch":["0","    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     *\n     * @return a {@code List} of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n"],"patch1-Lang-18-kPAR-plausible.patch":["0","    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     *\n     * @return a {@code List} of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n"],"patch3-Closure-18-SequenceR.patch":["0","  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"],"patch4-Closure-18-SequenceR.patch":["0","  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options.dependencyOptions)!=null)&&(options.dependencyOptions.needsManagement())){\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"],"patch5-Closure-18-SequenceR.patch":["0","  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options)==null)||(options.dependencyOptions.needsManagement())){\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"],"patch1-Closure-18-SequenceR.patch":["0","  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(options.dependencyOptions.needsManagement()){\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n"],"patch1-Lang-13-RSRepair-plausible.patch":["0","    /**\n     * <p>Deep clone an {@code Object} using serialization.</p>\n     *\n     * <p>This is many times slower than writing clone methods by hand\n     * on all objects in your object graph. However, for complex object\n     * graphs, or for those that don't support deep cloning this can\n     * be a simple alternative implementation. Of course all the objects\n     * must be {@code Serializable}.</p>\n     *\n     * @param <T> the type of the object involved\n     * @param object  the {@code Serializable} object to clone\n     * @return the cloned object\n     * @throws SerializationException (runtime) if the serialization fails\n     */\n    public static <T extends Serializable> T clone(T object) {\n        if (object == null) {\n            return null;\n        }\n        byte[] objectData = serialize(object);\n        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n\n        ClassLoaderAwareObjectInputStream in = null;\n        try {\n            // stream closed in the finally\n            in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n            /*\n             * when we serialize and deserialize an object,\n             * it is reasonable to assume the deserialized object\n             * is of the same type as the original serialized object\n             */\n            @SuppressWarnings(\"unchecked\") // see above\n            T readObject = (T) in.readObject();\n            return readObject;\n\n        } catch (ClassNotFoundException ex) {\n-            throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+            return object;\n        } catch (IOException ex) {\n            throw new SerializationException(\"IOException while reading cloned object data\", ex);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n                throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n            }\n        }\n    }\n"],"patch1-Lang-13-TBar-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Lang-13-AVATAR-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Lang-12-SimFix-plausible.patch":["0","    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n\n-        if (start == 0 && end == 0) {\n+        if(chars==null&&end==0){\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n"],"patch1-Closure-1-Kali-plausible.patch":["0","  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n+        if (false) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n"],"patch1-Closure-1-Arja-plausible.patch":["0","  /**\n   * Checks if the subtree under this node is the same as another subtree.\n   * Returns null if it's equal, or a message describing the differences.\n   */\n  public String checkTreeEquals(Node node2) {\n      NodeMismatch diff = checkTreeEqualsImpl(node2);\n      if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toString(true, true, true);\n      }\n      return null;\n  }\n"],"patch1-Math-105-DynaMoth-plausible.patch":["0","    /**\n     * Adds the observation (x,y) to the regression data set.\n     * <p>\n     * Uses updating formulas for means and sums of squares defined in \n     * \"Algorithms for Computing the Sample Variance: Analysis and\n     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985\n     *\n     *\n     * @param x independent variable value\n     * @param y dependent variable value\n     */\n    public void addData(double x, double y) {\n        if (n == 0) {\n-            xbar = x;\n+            if ((x <= 1) || (y <= x)) {\n+                xbar = x;\n+            }\n            ybar = y;\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n            xbar += dx / (double) (n + 1.0);\n            ybar += dy / (double) (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n    }\n"],"patch1-Math-105-Nopol-plausible.patch":["0","    /**\n     * Adds the observation (x,y) to the regression data set.\n     * <p>\n     * Uses updating formulas for means and sums of squares defined in \n     * \"Algorithms for Computing the Sample Variance: Analysis and\n     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985\n     *\n     *\n     * @param x independent variable value\n     * @param y dependent variable value\n     */\n    public void addData(double x, double y) {\n        if (n == 0) {\n-            xbar = x;\n+            if (((!((x) != (1))) && (!((x) != (1)))) || (y < x)) {\n+                xbar = x;\n+            }\n            ybar = y;\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n            xbar += dx / (double) (n + 1.0);\n            ybar += dy / (double) (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n    }\n"],"patch1-Math-104-AVATAR-plausible.patch":["0","    /**\n     * Returns the regularized gamma function P(a, x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n     * Regularized Gamma Function</a>, equation (1).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n     * Incomplete Gamma Function</a>, equation (4).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n     * </li>\n     * </ul>\n     * \n     * @param a the a parameter.\n     * @param x the value.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete. \n     * @return the regularized gamma function P(a, x)\n     * @throws MathException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaP(double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (a >= 1.0 && x >= a) {\n            // use regularizedGammaQ because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n        } else {\n            // calculate series\n            double n = 0.0; // current element index\n            double an = 1.0 / a; // n-th element in the series\n            double sum = an; // partial sum\n            while (Math.abs(an) > epsilon && n < maxIterations) {\n                // compute next element in the series\n                n = n + 1.0;\n                an = an * (x / (a + n));\n\n                // update partial sum\n                sum = sum + an;\n            }\n            if (n >= maxIterations) {\n                throw new MaxIterationsExceededException(maxIterations);\n            } else {\n                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n            }\n        }\n\n        return ret;\n    }\n"],"patch1-Math-104-kPAR-plausible.patch":["0","    /**\n     * Returns the regularized gamma function P(a, x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n     * Regularized Gamma Function</a>, equation (1).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n     * Incomplete Gamma Function</a>, equation (4).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n     * </li>\n     * </ul>\n     * \n     * @param a the a parameter.\n     * @param x the value.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete. \n     * @return the regularized gamma function P(a, x)\n     * @throws MathException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaP(double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (a >= 1.0 && x >= a) {\n            // use regularizedGammaQ because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n        } else {\n            // calculate series\n            double n = 0.0; // current element index\n            double an = 1.0 / a; // n-th element in the series\n            double sum = an; // partial sum\n            while (Math.abs(an) > epsilon && n < maxIterations) {\n                // compute next element in the series\n                n = n + 1.0;\n                an = an * (x / (a + n));\n\n                // update partial sum\n                sum = sum + an;\n            }\n            if (n >= maxIterations) {\n                throw new MaxIterationsExceededException(maxIterations);\n            } else {\n                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n            }\n        }\n\n        return ret;\n    }\n"],"patch1-Closure-119-Arja-plausible.patch":["0","  /**\n   * Scans and gather variables declarations under a Node\n   */\n  private void scanVars(Node n) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().isName());\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n-        declareVar(var);\n+        ;\n        scanVars(block);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        inputId = n.getInputId();\n        Preconditions.checkNotNull(inputId);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child);\n        child = next;\n      }\n    }\n  }\n"],"patch1-Closure-119-Kali-plausible.patch":["0","  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n-        if (!isGlobalExpr) {\n+        if (false) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\n          Name owner = isPrototypeGet ? name : parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }\n"],"patch1-Closure-117-Arja-plausible.patch":["0","  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n"],"patch1-Closure-117-Kali-plausible.patch":["0","      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isExprResult()) {\n          Node child = n.getFirstChild();\n          switch (child.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(child.getFirstChild(), child,\n                  child.getLastChild());\n              break;\n            case Token.GETPROP:\n-              maybeCollectMember(child, child, null);\n+              {\n+                if (true)\n+                    return;\n+                maybeCollectMember(child, child, null);\n+            }\n              break;\n          }\n        }\n      }\n"],"patch1-Closure-116-Arja-plausible.patch":["0","  /**\n   * Checks if the given function matches the criteria for an inlinable\n   * function, and if so, adds it to our set of inlinable functions.\n   */\n  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().isReturn()\n          && block.getFirstChild().getFirstChild() != null) {\n-        return true;\n+        return false;\n      }\n    }\n\n    return false;\n  }\n"],"patch1-Closure-115-kPAR-plausible.patch":["0","  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((!isDirectCallNodeReplacementPossible(fnNode)) && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n"],"patch1-Closure-115-TBar-plausible.patch":["0","  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) {\n            return CanInlineResult.NO;\n          }\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n"],"patch1-Closure-114-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-114-GenProg-plausible.patch":["0","  /**\n   * Replaces a node with the provided list.\n   */\n  final void replaceWith(Node parent, Node node, List<Node> replacements) {\n    Preconditions.checkNotNull(replacements, \"\\\"replacements\\\" is null.\");\n\n    int size = replacements.size();\n\n    if ((size == 1) && node.isEquivalentTo(replacements.get(0))) {\n      // trees are equal... don't replace\n      return;\n    }\n\n    int parentType = parent.getType();\n\n    Preconditions.checkState(size == 1 ||\n        parentType == Token.BLOCK ||\n        parentType == Token.SCRIPT ||\n        parentType == Token.LABEL);\n\n    if (parentType == Token.LABEL && size != 1) {\n      Node block = IR.block();\n      for (Node newChild : replacements) {\n        newChild.copyInformationFrom(node);\n        block.addChildToBack(newChild);\n      }\n      parent.replaceChild(node, block);\n    } else {\n      for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n+        final String paramName = \"jscomp_throw_param\";\n+        newChild.copyInformationFrom(node);\n        parent.addChildBefore(newChild, node);\n      }\n      parent.removeChild(node);\n    }\n    notifyOfRemoval(node);\n  }\n"],"patch1-Closure-114-RSRepair-plausible.patch":["0","  /**\n   * Replaces a node with the provided list.\n   */\n  final void replaceWith(Node parent, Node node, List<Node> replacements) {\n    Preconditions.checkNotNull(replacements, \"\\\"replacements\\\" is null.\");\n\n    int size = replacements.size();\n\n    if ((size == 1) && node.isEquivalentTo(replacements.get(0))) {\n      // trees are equal... don't replace\n      return;\n    }\n\n    int parentType = parent.getType();\n\n    Preconditions.checkState(size == 1 ||\n        parentType == Token.BLOCK ||\n        parentType == Token.SCRIPT ||\n        parentType == Token.LABEL);\n\n    if (parentType == Token.LABEL && size != 1) {\n      Node block = IR.block();\n      for (Node newChild : replacements) {\n        newChild.copyInformationFrom(node);\n        block.addChildToBack(newChild);\n      }\n      parent.replaceChild(node, block);\n    } else {\n      for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n        parent.addChildBefore(newChild, node);\n      }\n      parent.removeChild(node);\n    }\n    notifyOfRemoval(node);\n  }\n"],"patch1-Closure-114-Arja-plausible.patch":["0","  /**\n   * Get dependency scope defined by the enclosing function, or null.\n   * If enclosing function is a function expression, determine scope based on\n   * its parent if the parent node is a variable declaration or\n   * assignment.\n   */\n  private List<NameInformation> getEnclosingFunctionDependencyScope(\n      NodeTraversal t) {\n    Node function = t.getEnclosingFunction();\n    if (function == null) {\n      return Collections.emptyList();\n    }\n\n    List<NameInformation> refs = scopes.get(function);\n    if (!refs.isEmpty()) {\n      return refs;\n    }\n\n    // Function expression.  try to get a name from the parent var\n    // declaration or assignment.\n    Node parent = function.getParent();\n-    if (parent != null) {\n-      // Account for functions defined in the form:\n-      //   var a = cond ? function a() {} : function b() {};\n-      while (parent.isHook()) {\n-        parent = parent.getParent();\n-      }\n-\n-      if (parent.isName()) {\n-        return scopes.get(parent);\n-      }\n-\n-      if (parent.isAssign()) {\n-        return scopes.get(parent);\n-      }\n-    }\n-\n    return Collections.emptyList();\n  }\n"],"patch1-Closure-112-Arja-plausible.patch":["0","  private void maybeResolveTemplatedType(\n      JSType paramType,\n      JSType argType,\n      Map<TemplateType, JSType> resolvedTypes) {\n    if (paramType.isTemplateType()) {\n      // @param {T}\n      resolvedTemplateType(\n          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n    } else if (paramType.isUnionType()) {\n      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n      UnionType unionType = paramType.toMaybeUnionType();\n      for (JSType alernative : unionType.getAlternates()) {\n        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+        ;\n  }\n"],"patch1-Closure-112-RSRepair-plausible.patch":["0","  private void maybeResolveTemplateTypeFromNodes(\n      Iterable<Node> declParams,\n      Iterable<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n  }\n"],"patch1-Closure-112-GenProg-plausible.patch":["0","  private void maybeResolveTemplatedType(\n      JSType paramType,\n      JSType argType,\n      Map<TemplateType, JSType> resolvedTypes) {\n    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n    } else if (paramType.isUnionType()) {\n      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n      UnionType unionType = paramType.toMaybeUnionType();\n      for (JSType alernative : unionType.getAlternates()) {\n        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n      }\n    } else if (paramType.isFunctionType()) {\n      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n      FunctionType argFunctionType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion()\n          .toMaybeFunctionType();\n      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getTypeOfThis(),\n            argFunctionType.getTypeOfThis(), resolvedTypes);\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getReturnType(),\n            argFunctionType.getReturnType(), resolvedTypes);\n        // infer from parameter types of the function type\n        maybeResolveTemplateTypeFromNodes(\n            paramFunctionType.getParameters(),\n            argFunctionType.getParameters(), resolvedTypes);\n      }\n    } else if (paramType.isTemplatizedType()) {\n      // @param {Array.<T>}\n      ObjectType referencedParamType = paramType\n          .toMaybeTemplatizedType()\n          .getReferencedType();\n      JSType argObjectType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion();\n\n      if (argObjectType.isSubtype(referencedParamType)) {\n        // If the argument type is a subtype of the parameter type, resolve any\n        // template types amongst their templatized types.\n        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n          maybeResolveTemplatedType(\n              paramTypeMap.getTemplateType(key),\n              argTypeMap.getTemplateType(key),\n              resolvedTypes);\n        }\n      }\n    }\n  }\n"],"patch1-Closure-112-Kali-plausible.patch":["0","  private static void resolvedTemplateType(\n      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n+    if (false) {\n      if (previous == null) {\n        map.put(template, resolved);\n      } else {\n        JSType join = previous.getLeastSupertype(resolved);\n        map.put(template, join);\n      }\n    }\n  }\n"],"patch1-Closure-122-Kali-plausible.patch":["0","  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+    if (true) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n"],"patch1-Closure-22-SimFix-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType=parent.getParent().getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-Kali-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (false) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-RSRepair-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-jMutRepair-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n+          if (ancestorType >= Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-AVATAR-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (gramps == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-jGenProg-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-Arja-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+            ;\n+        else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-GenProg-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-jKali-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n+\n+\n+\n+\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-22-TBar-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n+          if (ancestorType>=Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-121-RSRepair-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n-    callback.process(externs, root);\n  }\n"],"patch1-Closure-121-Arja-plausible.patch":["0","  /**\n   * Resets global var reference map with the new provide map.\n   *\n   * @param globalRefMap The reference map result of a\n   *     {@link ReferenceCollectingCallback} pass collected from the whole AST.\n   */\n  private void resetGlobalVarReferences(\n      Map<Var, ReferenceCollection> globalRefMap) {\n    refMap = Maps.newHashMap();\n    for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n      Var var = entry.getKey();\n      if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n      }\n    }\n  }\n"],"patch1-Closure-121-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-20-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-120-RSRepair-plausible.patch":["0","  /**\n   * Updates block stack and invokes any additional behavior.\n   */\n  @Override\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n-      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }\n"],"patch1-Closure-120-Arja-plausible.patch":["0","  /**\n   * Resets global var reference map with the new provide map.\n   *\n   * @param globalRefMap The reference map result of a\n   *     {@link ReferenceCollectingCallback} pass collected from the whole AST.\n   */\n  private void resetGlobalVarReferences(\n      Map<Var, ReferenceCollection> globalRefMap) {\n    refMap = Maps.newHashMap();\n    for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n      Var var = entry.getKey();\n-      if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n-      }\n    }\n  }\n"],"patch1-Closure-120-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-21-TBar-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-jGenProg-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+\n+\n+\n+\n+\n+\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-SimFix-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType=parent.getParent().getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-Arja-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-jKali-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-AVATAR-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType = parent.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-GenProg-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n+      int start = 0;\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-jMutRepair-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType >= Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-Kali-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (true) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-21-RSRepair-plausible.patch":["0","  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n"],"patch1-Closure-26-SimFix-plausible.patch":["0","  private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.isAssign());\n\n    if (!late) {\n      return n;\n    }\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return n;\n    }\n\n    if (mayHaveSideEffects(left)) {\n      return n;\n    }\n\n    Node newRight;\n    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n+      n.removeChild(right);\n      newRight = right.getLastChild();\n    } else if (NodeUtil.isCommutative(right.getType()) &&\n          areNodesEqualForInlining(left, right.getLastChild())) {\n      newRight = right.getFirstChild();\n    } else {\n      return n;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return n;\n    }\n\n    Node newNode = new Node(newType,\n        left.detachFromParent(), newRight.detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }\n"],"patch1-Closure-26-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-103-RSRepair-plausible.patch":["0","    /**\n     * Returns the regularized gamma function P(a, x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n     * Regularized Gamma Function</a>, equation (1).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n     * Incomplete Gamma Function</a>, equation (4).</li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n     * </li>\n     * </ul>\n     * \n     * @param a the a parameter.\n     * @param x the value.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete. \n     * @return the regularized gamma function P(a, x)\n     * @throws MathException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaP(double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n        } else if (a >= 1.0 && x > a) {\n            // use regularizedGammaQ because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n        } else {\n            // calculate series\n            double n = 0.0; // current element index\n            double an = 1.0 / a; // n-th element in the series\n-            double sum = an; // partial sum\n+            if (Double.isNaN(x) || (x <= 0.0)) {\n+                ret = Double.NaN;\n+            } else {\n+                double g = 607.0 / 128.0;\n+                double sum = 0.0;\n+                for (int i = lanczos.length - 1; i > 0; --i) {\n+                    sum = sum + (lanczos[i] / (x + i));\n+                }\n+                sum = sum + lanczos[0];\n+                double tmp = x + g + .5;\n+                ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);\n+            }\n+            double sum = an; // partial sum\n            while (Math.abs(an) > epsilon && n < maxIterations) {\n                // compute next element in the series\n                n = n + 1.0;\n                an = an * (x / (a + n));\n\n                // update partial sum\n                sum = sum + an;\n            }\n            if (n >= maxIterations) {\n-                throw new MaxIterationsExceededException(maxIterations);\n            } else {\n                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n            }\n        }\n\n        return ret;\n    }\n"],"patch1-Lang-27-jKali-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n-            if (expPos > -1) {\n+            if (false) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-kPAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n+                mant = str.substring(0, INTEGER_ZERO);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-jMutRepair-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n-            if (expPos > -1) {\n+            if (expPos < -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-SimFix-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n+        str=str.toLowerCase();\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-jGenProg-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n-            } else {\n-                mant = str;\n+                mant = str;}else {                 mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-TBar-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n-            if (expPos > -1) {\n+            if (expPos<-1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-27-AVATAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n-            if (expPos > -1) {\n+            if (expPos < -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Math-31-Kali-plausible.patch":["0","    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double cN = a * hPrev + b * p0;\n            double q2 = a * q1 + b * dPrev;\n            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n                }\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                    } else if (b != 0) {\n                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                    }\n                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                        break;\n                    }\n                }\n            }\n\n            final double deltaN = cN / q2 / cPrev;\n            hN = cPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                if (true)\n+                    return -1;\n+                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }\n"],"patch1-Math-31-GenProg-plausible.patch":["0","    /**\n     * {@inheritDoc}\n     *\n     * For numerator degrees of freedom parameter {@code a} and denominator\n     * degrees of freedom parameter {@code b}, the variance is\n     * <ul>\n     *  <li>\n     *    if {@code b > 4} then\n     *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},\n     *  </li>\n     *  <li>else undefined ({@code Double.NaN}).\n     * </ul>\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n-            numericalVariance = calculateNumericalVariance();\n+            final double logm = FastMath.log(denominatorDegreesOfFreedom);\n+            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n"],"patch1-Closure-29-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Lang-24-TBar-plausible.patch":["0","    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n-            if (chars[i] == '.') {\n+            if ((chars[i] == '.') || (chars[i] == 'l'\n+                || chars[i] == 'L')) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n"],"patch1-Lang-24-kPAR-plausible.patch":["0","    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n-            if (chars[i] == '.') {\n+            if ((chars[i] == '.') || (chars[i] == 'l'\n+                || chars[i] == 'L')) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n"],"patch1-Math-32-Jaid-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) {\r\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n"],"patch1-Math-32-Kali-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n"],"patch1-Math-32-jKali-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n"],"patch1-Math-32-DynaMoth-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n"],"patch1-Math-33-Nopol-plausible.patch":["0","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n+                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) {\n+                    columnsToDrop.add(i);\n+                }\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"patch1-Math-33-RSRepair-plausible.patch":["0","    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n-            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n"],"patch1-Math-33-SketchFix-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Precision.compareTo(ratio, minRatio, maxUlps);\n+                if(rhs != minRatio) {\r\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n+        }\r\n\n        if (minRatioPositions.size() == 0) {\n          return null;\n        } else if (minRatioPositions.size() > 1) {\n          // there's a degeneracy as indicated by a tie in the minimum ratio test\n          // check if there's an artificial variable that can be forced out of the basis\n          for (Integer row : minRatioPositions) {\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n              int column = i + tableau.getArtificialVariableOffset();\n              final double entry = tableau.getEntry(row, column);\n              if (Precision.equals(entry, 1d, maxUlps) &&\n                  row.equals(tableau.getBasicRow(column))) {\n                return row;\n              }\n            }\n          }\n        }\n        return minRatioPositions.get(0);\n    }\n"],"patch1-Math-35-Arja.patch":["0","    /**\n     * Creates a new ElitisticListPopulation instance.\n     *\n     * @param chromosomes list of chromosomes in the population\n     * @param populationLimit maximal size of the population\n     * @param elitismRate how many best chromosomes will be directly transferred to the\n     *                    next generation [in %]\n     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n     */\n    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                   final int populationLimit,\n                                   final double elitismRate) {\n        super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        if (elitismRate < 0 || elitismRate > 1) {\n+            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n+        }\n    }\n"],"patch1-Lang-41-TBar-plausible.patch":["0","    /**\n     * <p>Gets the package name of a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the package name for, may be <code>null</code>.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n-        return getPackageName(cls.getName());\n+        return getPackageCanonicalName(cls.getName());\n    }\n"],"patch1-Lang-41-kPAR-plausible.patch":["0","    /**\n     * <p>Gets the package name of a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the package name for, may be <code>null</code>.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n-        return getPackageName(cls.getName());\n+        return getPackageCanonicalName(cls.getName());\n    }\n"],"patch1-Lang-41-SimFix-plausible.patch":["0","    /**\n     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the short name for.\n     * @return the class name without the package name or an empty string\n     */\n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n-        return getShortClassName(cls.getName());\n+        return getShortCanonicalName(cls.getName());\n    }\n"],"patch1-Lang-44-TBar-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n"],"patch1-Lang-44-kPAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n-                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n"],"patch1-Lang-44-Nopol-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n+                    if ((1) != (val.length())) {\n+                        if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n-                        try {\n-                            return createLong(numeric);\n-                        } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                            try {\n+                                return createLong(numeric);\n+                            } catch (NumberFormatException nfe) {\n+                                //Too big for a long\n+                            }\n+                            return createBigInteger(numeric);\n+                            \n                        }\n-                        return createBigInteger(numeric);\n-\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n"],"patch1-Lang-43-kPAR-plausible.patch":["0","    /**\n     * Apply the specified pattern.\n     * \n     * @param pattern String\n     */\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n-                appendQuotedString(pattern, pos, stripCustom, true);\n+                appendQuotedString(pattern, pos, stripCustom, false);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                // fall through\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3 \n            // seems to provide an extra format element:\n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n"],"patch1-Lang-43-CapGen-plausible.patch":["0","    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n+            getQuotedString(pattern, pos, false);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n"],"patch2-Lang-43-CapGen.patch":["0","    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n+        next(pos);\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n"],"patch1-Lang-43-CapGen.patch":["0","    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n+        next(pos);\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n"],"patch1-Lang-43-TBar-plausible.patch":["0","    /**\n     * Apply the specified pattern.\n     * \n     * @param pattern String\n     */\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n-                appendQuotedString(pattern, pos, stripCustom, true);\n+                appendQuotedString(pattern, pos, stripCustom, false);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                // fall through\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3 \n            // seems to provide an extra format element:\n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n"],"patch1-Math-93-ACS-plausible.patch":["0","    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n     * </ul>\n     * </p>\n     * \n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n"],"patch1-Closure-129-Kali-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        if (true)\n+            return true;\n+        return false;\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-129-kPAR-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        return (false) || !(recur);\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-129-FixMiner-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        return (false) || !(recur);\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-129-GenProg-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-129-RSRepair-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-129-Arja-plausible.patch":["0","  /**\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recur Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @param shallow If true, the method doesn't recur into inner functions.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  boolean isEquivalentTo(\n      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n      }\n    }\n\n    if (recur) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(\n            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n"],"patch1-Closure-127-Kali-plausible.patch":["0","    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+            if (false) {\n              removeNode(n);\n            }\n          }\n      }\n    }\n"],"patch1-Closure-127-RSRepair-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        return null;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-73-SequenceR.patch":["0","  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if((c> 31)&&(c<127)){\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n"],"patch1-Closure-126-SimFix-plausible.patch":["0","  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+        Node finallyBlock=n.getFirstChild().getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"],"patch1-Closure-126-kPAR-plausible.patch":["0","  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+        Node finallyBlock = n.getFirstChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"],"patch1-Closure-126-jMutRepair-plausible.patch":["0","  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (!NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"],"patch1-Closure-126-AVATAR-plausible.patch":["0","  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        tryMinimizeExits(allCatchNodes, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"],"patch1-Closure-126-TBar-plausible.patch":["0","  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        matchingExitNode(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n"],"patch1-Closure-125-Arja-plausible.patch":["0","  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    // Check for the typeof operator.\n    int operatorToken = condition.getType();\n    switch (operatorToken) {\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.CASE:\n        Node left;\n        Node right;\n        if (operatorToken == Token.CASE) {\n          left = condition.getParent().getFirstChild(); // the switch condition\n          right = condition.getFirstChild();\n        } else {\n          left = condition.getFirstChild();\n          right = condition.getLastChild();\n        }\n\n        Node typeOfNode = null;\n        Node stringNode = null;\n        if (left.isTypeOf() && right.isString()) {\n          typeOfNode = left;\n          stringNode = right;\n        } else if (right.isTypeOf() &&\n                   left.isString()) {\n          typeOfNode = right;\n          stringNode = left;\n        }\n        if (typeOfNode != null && stringNode != null) {\n          Node operandNode = typeOfNode.getFirstChild();\n          JSType operandType = getTypeIfRefinable(operandNode, blindScope);\n          if (operandType != null) {\n            boolean resultEqualsValue = operatorToken == Token.EQ ||\n                operatorToken == Token.SHEQ || operatorToken == Token.CASE;\n            if (!outcome) {\n              resultEqualsValue = !resultEqualsValue;\n            }\n            return caseTypeOf(operandNode, operandType, stringNode.getString(),\n                resultEqualsValue, blindScope);\n          }\n        }\n    }\n    switch (operatorToken) {\n      case Token.AND:\n        if (outcome) {\n          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, true);\n        } else {\n          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, true);\n        }\n\n      case Token.OR:\n        if (!outcome) {\n          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, false);\n        } else {\n          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, false);\n        }\n\n      case Token.EQ:\n        if (outcome) {\n          return caseEquality(condition, blindScope, EQ);\n        } else {\n          return caseEquality(condition, blindScope, NE);\n        }\n\n      case Token.NE:\n        if (outcome) {\n          return caseEquality(condition, blindScope, NE);\n        } else {\n          return caseEquality(condition, blindScope, EQ);\n        }\n\n      case Token.SHEQ:\n        if (outcome) {\n-          return caseEquality(condition, blindScope, SHEQ);\n        } else {\n          return caseEquality(condition, blindScope, SHNE);\n        }\n\n      case Token.SHNE:\n        if (outcome) {\n          return caseEquality(condition, blindScope, SHNE);\n        } else {\n          return caseEquality(condition, blindScope, SHEQ);\n        }\n\n      case Token.NAME:\n      case Token.GETPROP:\n        return caseNameOrGetProp(condition, blindScope, outcome);\n\n      case Token.ASSIGN:\n        return firstPreciserScopeKnowingConditionOutcome(\n            condition.getFirstChild(),\n            firstPreciserScopeKnowingConditionOutcome(\n                condition.getFirstChild().getNext(), blindScope, outcome),\n            outcome);\n\n      case Token.NOT:\n        return firstPreciserScopeKnowingConditionOutcome(\n            condition.getFirstChild(), blindScope, !outcome);\n\n      case Token.LE:\n      case Token.LT:\n      case Token.GE:\n      case Token.GT:\n        if (outcome) {\n          return caseEquality(condition, blindScope, ineq);\n        }\n        break;\n\n      case Token.INSTANCEOF:\n        return caseInstanceOf(\n            condition.getFirstChild(), condition.getLastChild(), blindScope,\n            outcome);\n\n      case Token.IN:\n        if (outcome && condition.getFirstChild().isString()) {\n          return caseIn(condition.getLastChild(),\n              condition.getFirstChild().getString(), blindScope);\n        }\n        break;\n\n      case Token.CASE:\n        Node left =\n            condition.getParent().getFirstChild(); // the switch condition\n        Node right = condition.getFirstChild();\n        if (outcome) {\n          return caseEquality(left, right, blindScope, SHEQ);\n        } else {\n          return caseEquality(left, right, blindScope, SHNE);\n        }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }\n"],"patch1-Closure-125-Kali-plausible.patch":["0","  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    // Check for the typeof operator.\n    int operatorToken = condition.getType();\n    switch (operatorToken) {\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.CASE:\n        Node left;\n        Node right;\n        if (operatorToken == Token.CASE) {\n          left = condition.getParent().getFirstChild(); // the switch condition\n          right = condition.getFirstChild();\n        } else {\n          left = condition.getFirstChild();\n          right = condition.getLastChild();\n        }\n\n        Node typeOfNode = null;\n        Node stringNode = null;\n        if (left.isTypeOf() && right.isString()) {\n          typeOfNode = left;\n          stringNode = right;\n        } else if (right.isTypeOf() &&\n                   left.isString()) {\n          typeOfNode = right;\n          stringNode = left;\n        }\n        if (typeOfNode != null && stringNode != null) {\n          Node operandNode = typeOfNode.getFirstChild();\n          JSType operandType = getTypeIfRefinable(operandNode, blindScope);\n          if (operandType != null) {\n            boolean resultEqualsValue = operatorToken == Token.EQ ||\n                operatorToken == Token.SHEQ || operatorToken == Token.CASE;\n            if (!outcome) {\n              resultEqualsValue = !resultEqualsValue;\n            }\n            return caseTypeOf(operandNode, operandType, stringNode.getString(),\n                resultEqualsValue, blindScope);\n          }\n        }\n    }\n    switch (operatorToken) {\n      case Token.AND:\n        if (outcome) {\n          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, true);\n        } else {\n          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, true);\n        }\n\n      case Token.OR:\n        if (!outcome) {\n          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, false);\n        } else {\n          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n              condition.getLastChild(), blindScope, false);\n        }\n\n      case Token.EQ:\n        if (outcome) {\n          return caseEquality(condition, blindScope, EQ);\n        } else {\n          return caseEquality(condition, blindScope, NE);\n        }\n\n      case Token.NE:\n        if (outcome) {\n          return caseEquality(condition, blindScope, NE);\n        } else {\n          return caseEquality(condition, blindScope, EQ);\n        }\n\n      case Token.SHEQ:\n-        if (outcome) {\n+        if (false) {\n          return caseEquality(condition, blindScope, SHEQ);\n        } else {\n          return caseEquality(condition, blindScope, SHNE);\n        }\n\n      case Token.SHNE:\n        if (outcome) {\n          return caseEquality(condition, blindScope, SHNE);\n        } else {\n          return caseEquality(condition, blindScope, SHEQ);\n        }\n\n      case Token.NAME:\n      case Token.GETPROP:\n        return caseNameOrGetProp(condition, blindScope, outcome);\n\n      case Token.ASSIGN:\n        return firstPreciserScopeKnowingConditionOutcome(\n            condition.getFirstChild(),\n            firstPreciserScopeKnowingConditionOutcome(\n                condition.getFirstChild().getNext(), blindScope, outcome),\n            outcome);\n\n      case Token.NOT:\n        return firstPreciserScopeKnowingConditionOutcome(\n            condition.getFirstChild(), blindScope, !outcome);\n\n      case Token.LE:\n      case Token.LT:\n      case Token.GE:\n      case Token.GT:\n        if (outcome) {\n          return caseEquality(condition, blindScope, ineq);\n        }\n        break;\n\n      case Token.INSTANCEOF:\n        return caseInstanceOf(\n            condition.getFirstChild(), condition.getLastChild(), blindScope,\n            outcome);\n\n      case Token.IN:\n        if (outcome && condition.getFirstChild().isString()) {\n          return caseIn(condition.getLastChild(),\n              condition.getFirstChild().getString(), blindScope);\n        }\n        break;\n\n      case Token.CASE:\n        Node left =\n            condition.getParent().getFirstChild(); // the switch condition\n        Node right = condition.getFirstChild();\n        if (outcome) {\n          return caseEquality(left, right, blindScope, SHEQ);\n        } else {\n          return caseEquality(left, right, blindScope, SHNE);\n        }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }\n"],"patch1-Closure-124-RSRepair-plausible.patch":["0","  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n"],"patch1-Closure-124-Arja-plausible.patch":["0","  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n-            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n"],"patch1-Closure-124-GenProg-plausible.patch":["0","  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n"],"patch1-Closure-124-Kali-plausible.patch":["0","  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n+    if (true) {\n      return false;\n    }\n\n    return true;\n  }\n"],"patch1-Closure-72-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-123-SequenceR.patch":["0","  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE;\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          // Check for ECMASCRIPT3 keywords.\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n"],"patch1-Closure-133-Arja-plausible.patch":["0","  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n-    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n"],"patch1-Closure-133-TBar-plausible.patch":["0","  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  @SuppressWarnings(\"incomplete-switch\")\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case NG_INJECT:\n                  if (jsdocBuilder.isNgInjectRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                      stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.recordNgInject(true);\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE: {\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n                }\n\n                case CLASS_TEMPLATE: {\n                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(classTemplateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.missing.type.name\",\n                        stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.classtemplate.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = classTemplateInfo.token;\n                  continue retry;\n                }\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n-                              extractMultilineTextualBlock(token);\n+                              extractMultilineTextualBlock(current());\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n"],"patch1-Closure-132-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-78-Arja-plausible.patch":["0","  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n    Node result = performArithmeticOp(n.getType(), left, right);\n    if (result != null) {\n      result.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, result);\n      reportCodeChange();\n      return result;\n    }\n-    return n;\n+    return null;\n  }\n"],"patch1-Closure-78-GenProg-plausible.patch":["0","  /**\n   * Helper method for reporting an error to the compiler when applying a\n   * peephole optimization.\n   *\n   * @param diagnostic The error type\n   * @param n The node for which the error should be reported\n   */\n  protected void error(DiagnosticType diagnostic, Node n) {\n    JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    int start = 0;\n  }\n"],"patch1-Closure-78-Kali-plausible.patch":["0","  /**\n   * Helper method for reporting an error to the compiler when applying a\n   * peephole optimization.\n   *\n   * @param diagnostic The error type\n   * @param n The node for which the error should be reported\n   */\n  protected void error(DiagnosticType diagnostic, Node n) {\n    JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    if (true)\n+        return;\n+    currentTraversal.getCompiler().report(error);\n  }\n"],"patch1-Closure-78-RSRepair-plausible.patch":["0","  /**\n   * Helper method for reporting an error to the compiler when applying a\n   * peephole optimization.\n   *\n   * @param diagnostic The error type\n   * @param n The node for which the error should be reported\n   */\n  protected void error(DiagnosticType diagnostic, Node n) {\n    JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n  }\n"],"patch1-Closure-75-Kali-plausible.patch":["0","  static Double getStringNumberValue(String rawJsString) {\n      // vertical tab is not always whitespace\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n-    if (s.length() > 3\n-        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n-        && s.charAt(1) == '0'\n-        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n+    if (true) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }\n"],"patch1-Closure-75-RSRepair-plausible.patch":["0","  /**\n   * Gets the value of a node as a Number, or null if it cannot be converted.\n   * When it returns a non-null Double, this method effectively emulates the\n   * <code>Number()</code> JavaScript cast function.\n   */\n  static Double getNumberValue(Node n) {\n    switch (n.getType()) {\n      case Token.TRUE:\n        return 1.0;\n\n      case Token.FALSE:\n      case Token.NULL:\n        return 0.0;\n\n      case Token.NUMBER:\n        return n.getDouble();\n\n      case Token.VOID:\n        if (mayHaveSideEffects(n.getFirstChild())) {\n          return null;\n        } else {\n          return Double.NaN;\n        }\n\n      case Token.NAME:\n        // Check for known constants\n        String name = n.getString();\n        if (name.equals(\"undefined\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"NaN\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"Infinity\")) {\n          return Double.POSITIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NEG:\n        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME\n            && n.getFirstChild().getString().equals(\"Infinity\")) {\n          return Double.NEGATIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.\n        }\n        break;\n\n      case Token.STRING:\n-        return getStringNumberValue(n.getString());\n+        break;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        String value = getStringValue(n);\n        return value != null ? getStringNumberValue(value) : null;\n    }\n\n    return null;\n  }\n"],"patch1-Closure-75-Arja-plausible.patch":["0","  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n"],"patch1-Closure-75-GenProg-plausible.patch":["0","  public static String name(int token)\n    {\n        if (!printNames) {\n            return String.valueOf(token);\n        }\n        switch (token) {\n          case ERROR:           return \"ERROR\";\n          case EOF:             return \"EOF\";\n          case EOL:             return \"EOL\";\n          case ENTERWITH:       return \"ENTERWITH\";\n          case LEAVEWITH:       return \"LEAVEWITH\";\n          case RETURN:          return \"RETURN\";\n          case GOTO:            return \"GOTO\";\n          case IFEQ:            return \"IFEQ\";\n          case IFNE:            return \"IFNE\";\n          case SETNAME:         return \"SETNAME\";\n          case BITOR:           return \"BITOR\";\n          case BITXOR:          return \"BITXOR\";\n          case BITAND:          return \"BITAND\";\n          case EQ:              return \"EQ\";\n          case NE:              return \"NE\";\n          case LT:              return \"LT\";\n          case LE:              return \"LE\";\n          case GT:              return \"GT\";\n          case GE:              return \"GE\";\n          case LSH:             return \"LSH\";\n          case RSH:             return \"RSH\";\n          case URSH:            return \"URSH\";\n          case ADD:             return \"ADD\";\n          case SUB:             return \"SUB\";\n          case MUL:             return \"MUL\";\n          case DIV:             return \"DIV\";\n          case MOD:             return \"MOD\";\n          case NOT:             return \"NOT\";\n          case BITNOT:          return \"BITNOT\";\n-          case POS:             return \"POS\";\n+          case POS:             ;\n          case NEG:             return \"NEG\";\n          case NEW:             return \"NEW\";\n          case DELPROP:         return \"DELPROP\";\n          case TYPEOF:          return \"TYPEOF\";\n          case GETPROP:         return \"GETPROP\";\n          case SETPROP:         return \"SETPROP\";\n          case GETELEM:         return \"GETELEM\";\n          case SETELEM:         return \"SETELEM\";\n          case CALL:            return \"CALL\";\n          case NAME:            return \"NAME\";\n          case LABEL_NAME:      return \"LABEL_NAME\";\n          case NUMBER:          return \"NUMBER\";\n          case STRING:          return \"STRING\";\n          case NULL:            return \"NULL\";\n          case THIS:            return \"THIS\";\n          case FALSE:           return \"FALSE\";\n          case TRUE:            return \"TRUE\";\n          case SHEQ:            return \"SHEQ\";\n          case SHNE:            return \"SHNE\";\n          case REGEXP:          return \"REGEXP\";\n          case BINDNAME:        return \"BINDNAME\";\n          case THROW:           return \"THROW\";\n          case RETHROW:         return \"RETHROW\";\n          case IN:              return \"IN\";\n          case INSTANCEOF:      return \"INSTANCEOF\";\n          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n          case GETVAR:          return \"GETVAR\";\n          case SETVAR:          return \"SETVAR\";\n          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n          case ENUM_INIT_VALUES:  return \"ENUM_INIT_VALUES\";\n          case ENUM_NEXT:       return \"ENUM_NEXT\";\n          case ENUM_ID:         return \"ENUM_ID\";\n          case THISFN:          return \"THISFN\";\n          case RETURN_RESULT:   return \"RETURN_RESULT\";\n          case ARRAYLIT:        return \"ARRAYLIT\";\n          case OBJECTLIT:       return \"OBJECTLIT\";\n          case GET_REF:         return \"GET_REF\";\n          case SET_REF:         return \"SET_REF\";\n          case DEL_REF:         return \"DEL_REF\";\n          case REF_CALL:        return \"REF_CALL\";\n          case REF_SPECIAL:     return \"REF_SPECIAL\";\n          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n          case ESCXMLATTR:      return \"ESCXMLATTR\";\n          case REF_MEMBER:      return \"REF_MEMBER\";\n          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n          case REF_NAME:        return \"REF_NAME\";\n          case REF_NS_NAME:     return \"REF_NS_NAME\";\n          case TRY:             return \"TRY\";\n          case SEMI:            return \"SEMI\";\n          case LB:              return \"LB\";\n          case RB:              return \"RB\";\n          case LC:              return \"LC\";\n          case RC:              return \"RC\";\n          case LP:              return \"LP\";\n          case RP:              return \"RP\";\n          case COMMA:           return \"COMMA\";\n          case ASSIGN:          return \"ASSIGN\";\n          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n          case HOOK:            return \"HOOK\";\n          case COLON:           return \"COLON\";\n          case OR:              return \"OR\";\n          case AND:             return \"AND\";\n          case INC:             return \"INC\";\n          case DEC:             return \"DEC\";\n          case DOT:             return \"DOT\";\n          case FUNCTION:        return \"FUNCTION\";\n          case EXPORT:          return \"EXPORT\";\n          case IMPORT:          return \"IMPORT\";\n          case IF:              return \"IF\";\n          case ELSE:            return \"ELSE\";\n          case SWITCH:          return \"SWITCH\";\n          case CASE:            return \"CASE\";\n          case DEFAULT:         return \"DEFAULT\";\n          case WHILE:           return \"WHILE\";\n          case DO:              return \"DO\";\n          case FOR:             return \"FOR\";\n          case BREAK:           return \"BREAK\";\n          case CONTINUE:        return \"CONTINUE\";\n          case VAR:             return \"VAR\";\n          case WITH:            return \"WITH\";\n          case CATCH:           return \"CATCH\";\n          case FINALLY:         return \"FINALLY\";\n          case RESERVED:        return \"RESERVED\";\n          case EMPTY:           return \"EMPTY\";\n          case BLOCK:           return \"BLOCK\";\n          case LABEL:           return \"LABEL\";\n          case TARGET:          return \"TARGET\";\n          case LOOP:            return \"LOOP\";\n          case EXPR_VOID:       return \"EXPR_VOID\";\n          case EXPR_RESULT:     return \"EXPR_RESULT\";\n          case JSR:             return \"JSR\";\n          case SCRIPT:          return \"SCRIPT\";\n          case TYPEOFNAME:      return \"TYPEOFNAME\";\n          case USE_STACK:       return \"USE_STACK\";\n          case SETPROP_OP:      return \"SETPROP_OP\";\n          case SETELEM_OP:      return \"SETELEM_OP\";\n          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n          case SET_REF_OP:      return \"SET_REF_OP\";\n          case DOTDOT:          return \"DOTDOT\";\n          case COLONCOLON:      return \"COLONCOLON\";\n          case XML:             return \"XML\";\n          case DOTQUERY:        return \"DOTQUERY\";\n          case XMLATTR:         return \"XMLATTR\";\n          case XMLEND:          return \"XMLEND\";\n          case TO_OBJECT:       return \"TO_OBJECT\";\n          case TO_DOUBLE:       return \"TO_DOUBLE\";\n          case GET:             return \"GET\";\n          case SET:             return \"SET\";\n          case CONST:           return \"CONST\";\n          case SETCONST:        return \"SETCONST\";\n          case DEBUGGER:        return \"DEBUGGER\";\n          case ANNOTATION:      return \"ANNOTATION\";\n          case PIPE:            return \"PIPE\";\n          case STAR:            return \"STAR\";\n          case EOC:             return \"EOC\";\n          case QMARK:           return \"QMARK\";\n          case ELLIPSIS:        return \"ELLIPSIS\";\n          case BANG:            return \"BANG\";\n          case VOID:            return \"VOID\";\n          case EQUALS:          return \"EQUALS\";\n        }\n\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }\n"],"patch1-Closure-131-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-76-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-130-Kali-plausible.patch":["0","    boolean firstReferenceIsAssigningDeclaration() {\n      int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n+      if (false) {\n        return true;\n      }\n      return false;\n    }\n"],"patch1-Closure-130-Arja-plausible.patch":["0","  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }\n"],"patch1-Closure-130-RSRepair-plausible.patch":["0","  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }\n"],"patch1-Closure-130-GenProg-plausible.patch":["0","  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }\n"],"patch1-Lang-39-jGenProg-plausible.patch":["0","    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n-            if (greater > 0) {\n-                increase += 3 * greater; // assume 3 matches\n-            }\n-        }\n+\n+\n+\n+\n+\n+\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"],"patch1-Lang-39-AVATAR-plausible.patch":["0","    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            int greater = searchList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"],"patch1-Lang-39-TBar-plausible.patch":["0","    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n+        for (int i = 0; i==searchList.length; i++) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n"],"patch1-Closure-8-Arja-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root, new GatherCollapses());\n\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n-      compiler.reportCodeChange();\n    }\n  }\n"],"patch1-Closure-8-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-84-Kali-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (true) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-kPAR-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-SimFix-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n+            if(comparator.compare(contracted,best)<=0){\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-FixMiner-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-jMutRepair-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) == 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-RSRepair-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n-            incrementIterationsCounter();\n+            final double[] xSmallest = simplex[0].getPointRef();\n+            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            return;\n\n        }\n\n    }\n"],"patch1-Math-84-jGenProg-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n-            }\n+            }             return;\n\n        }\n\n    }\n"],"patch1-Math-84-AVATAR-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Math-84-Arja-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            break;\n\n        }\n\n    }\n"],"patch1-Math-84-TBar-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best)==0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n"],"patch1-Closure-7-Arja-plausible.patch":["0","  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  boolean checkUnionEquivalenceHelper(\n      UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n-      return false;\n+      return true;\n    }\n    for (JSType alternate : that.alternates) {\n      if (!hasAlternate(alternate, tolerateUnknowns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n"],"patch1-Closure-7-Kali-plausible.patch":["0","    @Override\n    public JSType caseUnionType(UnionType type) {\n      JSType restricted = null;\n      for (JSType alternate : type.getAlternates()) {\n        JSType restrictedAlternate = alternate.visit(this);\n        if (restrictedAlternate != null) {\n          if (restricted == null) {\n            restricted = restrictedAlternate;\n          } else {\n-            restricted = restrictedAlternate.getLeastSupertype(restricted);\n+            if (true)\n+                return null;\n+            restricted = restrictedAlternate.getLeastSupertype(restricted);\n          }\n        }\n      }\n      return restricted;\n    }\n"],"patch17-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&((initial)!=0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-Jaid-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) {\r\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-FixMiner-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch5-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa*maximumIterations)> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-RSRepair-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch13-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&(fa> 0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-SimFix-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+if(fa*upperBound>=0.0){\n+throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch2-Math-85-CapGen-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * b >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch2-Math-85-Jaid-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb > 0.0 || fa * fb >= 0.0) != true) {\r\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch2-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa*0.0)> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch10-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> fb)&&((fa*fb)>=0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch4-Math-85-Jaid-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) {\r\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-Cardumen-plausible.patch":["0","    /**\n     * Access the domain value lower bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value lower bound, i.e.\n     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n     */\n    @Override\n    protected double getDomainLowerBound(double p) {\n        double ret;\n\n        if (p < .5) {\n            ret = -Double.MAX_VALUE;\n        } else {\n-            ret = getMean();\n+            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0)));\n        }\n        \n        return ret;\n    }\n"],"patch1-Math-85-GenProg-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n-            b = Math.min(b + 1.0, upperBound);\n+            int i = 0;\n+            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch6-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> 0.0)&&((fa*fb)>=0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch9-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> 0.0)&&((fa*fb)> 0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch14-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.max((fa*0.0),0.0))> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch3-Math-85-CapGen-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (((fa * fb) > 0.0) && (numIterations < maximumIterations) ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-Arja-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch12-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.max((fa*fb),0.0))> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch4-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa)>=0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-TBar-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch16-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa)==0.0)||((fa*fb)> 0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch15-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.min((fa*fb),0.0))> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-DynaMoth-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            if (false) {\n+                throw new ConvergenceException(\n+                \"number of iterations={0}, maximum iterations={1}, \" +\n+                \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+                \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                numIterations, maximumIterations, initial,\n+                lowerBound, upperBound, a, b, fa, fb);\n+            }\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch8-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa!=fb)&&((fa)>=0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch3-Math-85-Jaid-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if ((fa * fb >= 0.0 == initial > upperBound) != false && fa * fb >= 0.0) {\r\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch7-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa!=fb)&&((fa*fb)> 0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-CapGen-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * upperBound >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch11-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&((fa)!=0.0)){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Math-85-jGenProg-plausible.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+\n+\n+\n+\n+\n+\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch3-Math-85-SequenceR.patch":["0","     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n-        if (fa * fb >= 0.0 ) {\n+        if((fa)> 0.0){\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n"],"patch1-Lang-35-ACS.patch":["0","    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n-        return newArray;\n+if (element == null){throw new IllegalArgumentException();}        return newArray;\n    }\n"],"patch1-Math-87-Nopol-plausible.patch":["0","    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected double[][] createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        List<LinearConstraint> constraints = getNormalizedConstraints();\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        double[][] matrix = new double[height][width];\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix[0][0] = -1;\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n            matrix[zIndex][width - 1] =\n                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n\n                if (!restrictToNonNegative) {\n                    matrix[zIndex][getSlackVariableOffset() - 1] =\n                        getInvertedCoeffiecientSum(objectiveCoefficients);\n                }\n\n                // initialize the constraint rows\n                int slackVar = 0;\n                int artificialVar = 0;\n                for (int i = 0; i < constraints.size(); i++) {\n                    LinearConstraint constraint = constraints.get(i);\n                    int row = getNumObjectiveFunctions() + i;\n\n                    // decision variable coefficients\n                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n\n                    // x-\n                    if (!restrictToNonNegative) {\n-                        matrix[row][getSlackVariableOffset() - 1] =\n+                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) {\n+                            matrix[row][getSlackVariableOffset() - 1] =\n                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                        }\n                    }\n\n                    // RHS\n                    matrix[row][width - 1] = constraint.getValue();\n\n                    // slack variables\n                    if (constraint.getRelationship() == Relationship.LEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n                    }\n\n                    // artificial variables\n                    if ((constraint.getRelationship() == Relationship.EQ) ||\n                        (constraint.getRelationship() == Relationship.GEQ)) {\n                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n                    }\n                }\n\n                return matrix;\n    }\n"],"patch1-Closure-5-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-88-TBar-plausible.patch":["0","    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"],"patch1-Math-88-SimFix-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn()}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n                double ratio = rhs / tableau.getEntry(i, col);\n-                if (ratio < minRatio) {\n+                if(ratio<=minRatio){\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-88-jMutRepair-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn()}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n                double ratio = rhs / tableau.getEntry(i, col);\n-                if (ratio < minRatio) {\n+                if (ratio <= minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-88-AVATAR-plausible.patch":["0","    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"],"patch1-Math-88-kPAR-plausible.patch":["0","    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"],"patch1-Closure-3-Kali-plausible.patch":["0","    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n"],"patch1-Lang-53-Nopol-plausible.patch":["0","    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n-        if (date.getTime() != time) {\n-            date.setTime(time);\n-            val.setTime(date);\n+        if (seconds <= org.apache.commons.lang.time.DateUtils.fields.length) {\n+            if (date.getTime() != time) {\n+                date.setTime(time);\n+                val.setTime(date);\n+            }\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n"],"patch1-Lang-53-kPAR-plausible.patch":["0","    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n-        if (date.getTime() != time) {\n+        if ((!round || millisecs < 500)) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n"],"patch1-Chart-3-Arja-plusible.patch":["0","    /**\r\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\r\n     *              permitted).\r\n     * @param notify  notify listeners?\r\n     */\r\n    public void add(TimeSeriesDataItem item, boolean notify) {\r\n        if (item == null) {\r\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\r\n        }\r\n        item = (TimeSeriesDataItem) item.clone();\r\n        Class c = item.getPeriod().getClass();\r\n        if (this.timePeriodClass == null) {\r\n            this.timePeriodClass = c;\r\n-        }\n-        else if (!this.timePeriodClass.equals(c)) {\n-            StringBuffer b = new StringBuffer();\n-            b.append(\"You are trying to add data where the time period class \");\n-            b.append(\"is \");\n-            b.append(item.getPeriod().getClass().getName());\n-            b.append(\", but the TimeSeries is expecting an instance of \");\n-            b.append(this.timePeriodClass.getName());\n-            b.append(\".\");\n-            throw new SeriesException(b.toString());\n-        }\n+        } else\n+            findBoundsByIteration();\n\r\n        // make the change (if it's not a duplicate time period)...\r\n        boolean added = false;\r\n        int count = getItemCount();\r\n        if (count == 0) {\r\n            this.data.add(item);\r\n            added = true;\r\n        }\r\n        else {\r\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\r\n            if (item.getPeriod().compareTo(last) > 0) {\r\n                this.data.add(item);\r\n                added = true;\r\n            }\r\n            else {\r\n                int index = Collections.binarySearch(this.data, item);\r\n                if (index < 0) {\r\n                    this.data.add(-index - 1, item);\r\n                    added = true;\r\n                }\r\n                else {\r\n                    StringBuffer b = new StringBuffer();\r\n                    b.append(\"You are attempting to add an observation for \");\r\n                    b.append(\"the time period \");\r\n                    b.append(item.getPeriod().toString());\r\n                    b.append(\" but the series already contains an observation\");\r\n                    b.append(\" for that time period. Duplicates are not \");\r\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\r\n                    throw new SeriesException(b.toString());\r\n                }\r\n            }\r\n        }\r\n        if (added) {\r\n            updateBoundsForAddedItem(item);\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\r\n                updateBoundsForRemovedItem(d);\r\n            }\r\n\r\n            removeAgedItems(false);  // remove old items if necessary, but\r\n                                     // don't notify anyone, because that\r\n                                     // happens next anyway...\r\n            if (notify) {\r\n                fireSeriesChanged();\r\n            }\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-3-jGenProg-plausible.patch":["0","    /**\r\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\r\n     *              permitted).\r\n     */\r\n    public void add(TimeSeriesDataItem item) {\r\n+        updateBoundsForRemovedItem(item);\n        add(item, true);\r\n    }\r\n"],"patch1-Chart-3-TBar-plausible.patch":["0","    /**\r\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\r\n     *              permitted).\r\n     */\r\n    public void add(TimeSeriesDataItem item) {\r\n-        add(item, true);\n+        updateBoundsForRemovedItem(item);\n+        add(item, true);\n    }\r\n"],"patch1-Chart-3-kPAR-plausible.patch":["0","    /**\r\n     * Age items in the series.  Ensure that the timespan from the youngest to\r\n     * the oldest record in the series does not exceed maximumItemAge time\r\n     * periods.  Oldest items will be removed if required.\r\n     *\r\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\r\n     *                sent to registered listeners IF any items are removed.\r\n     */\r\n    public void removeAgedItems(boolean notify) {\r\n        // check if there are any values earlier than specified by the history\r\n        // count...\r\n        if (getItemCount() > 1) {\r\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\r\n            boolean removed = false;\r\n            while ((latest - getTimePeriod(0).getSerialIndex())\r\n                    > this.maximumItemAge) {\r\n                this.data.remove(0);\r\n                removed = true;\r\n            }\r\n-            if (removed) {\n+            if ((removed) || !(notify)) {\n                findBoundsByIteration();\r\n                if (notify) {\r\n                    fireSeriesChanged();\r\n                }\r\n            }\r\n        }\r\n    }\r\n"],"patch1-Chart-3-GenProg-plausible.patch":["0","    /**\r\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\r\n     *              permitted).\r\n     * @param notify  notify listeners?\r\n     */\r\n    public void add(TimeSeriesDataItem item, boolean notify) {\r\n-        if (item == null) {\n-            throw new IllegalArgumentException(\"Null 'item' argument.\");\n-        }\n+        updateBoundsForRemovedItem(item);\n        item = (TimeSeriesDataItem) item.clone();\r\n        Class c = item.getPeriod().getClass();\r\n        if (this.timePeriodClass == null) {\r\n            this.timePeriodClass = c;\r\n        }\r\n        else if (!this.timePeriodClass.equals(c)) {\r\n            StringBuffer b = new StringBuffer();\r\n            b.append(\"You are trying to add data where the time period class \");\r\n            b.append(\"is \");\r\n            b.append(item.getPeriod().getClass().getName());\r\n            b.append(\", but the TimeSeries is expecting an instance of \");\r\n            b.append(this.timePeriodClass.getName());\r\n            b.append(\".\");\r\n            throw new SeriesException(b.toString());\r\n        }\r\n\r\n        // make the change (if it's not a duplicate time period)...\r\n        boolean added = false;\r\n        int count = getItemCount();\r\n        if (count == 0) {\r\n            this.data.add(item);\r\n            added = true;\r\n        }\r\n        else {\r\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\r\n            if (item.getPeriod().compareTo(last) > 0) {\r\n                this.data.add(item);\r\n                added = true;\r\n            }\r\n            else {\r\n                int index = Collections.binarySearch(this.data, item);\r\n                if (index < 0) {\r\n                    this.data.add(-index - 1, item);\r\n                    added = true;\r\n                }\r\n                else {\r\n                    StringBuffer b = new StringBuffer();\r\n                    b.append(\"You are attempting to add an observation for \");\r\n                    b.append(\"the time period \");\r\n                    b.append(item.getPeriod().toString());\r\n                    b.append(\" but the series already contains an observation\");\r\n                    b.append(\" for that time period. Duplicates are not \");\r\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\r\n                    throw new SeriesException(b.toString());\r\n                }\r\n            }\r\n        }\r\n        if (added) {\r\n            updateBoundsForAddedItem(item);\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\r\n                updateBoundsForRemovedItem(d);\r\n            }\r\n\r\n            removeAgedItems(false);  // remove old items if necessary, but\r\n                                     // don't notify anyone, because that\r\n                                     // happens next anyway...\r\n            if (notify) {\r\n                fireSeriesChanged();\r\n            }\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-3-FixMiner-plausible.patch":["0","    /**\r\n     * Age items in the series.  Ensure that the timespan from the youngest to\r\n     * the oldest record in the series does not exceed maximumItemAge time\r\n     * periods.  Oldest items will be removed if required.\r\n     *\r\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\r\n     *                sent to registered listeners IF any items are removed.\r\n     */\r\n    public void removeAgedItems(boolean notify) {\r\n        // check if there are any values earlier than specified by the history\r\n        // count...\r\n        if (getItemCount() > 1) {\r\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\r\n            boolean removed = false;\r\n            while ((latest - getTimePeriod(0).getSerialIndex())\r\n                    > this.maximumItemAge) {\r\n                this.data.remove(0);\r\n                removed = true;\r\n            }\r\n-            if (removed) {\n+            if ((removed) || !(notify)) {\n                findBoundsByIteration();\r\n                if (notify) {\r\n                    fireSeriesChanged();\r\n                }\r\n            }\r\n        }\r\n    }\r\n"],"patch1-Chart-3-SimFix-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end)\r\n            throws CloneNotSupportedException {\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n        if (end < start) {\r\n            throw new IllegalArgumentException(\"Requires start <= end.\");\r\n        }\r\n+        this.maxY=1.0;\n        TimeSeries copy = (TimeSeries) super.clone();\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item\r\n                        = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"patch1-Chart-6-Cardumen-plausible.patch":["0","    /**\n     * Sets the {@link Shape} for an item in the list.  The list is expanded \n\t * if necessary.\n     *\n     * @param index  the index (zero-based).\n     * @param shape  the {@link Shape}.\n     */\n    public void setShape(int index, Shape shape) {\n-        set(index, shape);\n+        set(org.jfree.chart.util.AbstractObjectList.DEFAULT_INITIAL_CAPACITY, shape);\n    }\n"],"patch1-Lang-55-Nopol-plausible.patch":["0","    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n-            stopTime = System.currentTimeMillis();\n+            if (org.apache.commons.lang.time.StopWatch.this.stopTime < 10) {\n+                stopTime = System.currentTimeMillis();\n+            }\n        this.runningState = STATE_STOPPED;\n    }\n"],"patch1-Lang-55-Jaid-plausible.patch":["0","    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n+        if((this.runningState == 1) == false){\r\n+        \treturn;\r\n+        \t}\r\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }\n"],"patch2-Lang-55-Jaid-plausible.patch":["0","    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n+        if((this.runningState > 1) == true){\r\n+        \tthis.runningState=1;\r\n+        \t}else{\r\n            stopTime = System.currentTimeMillis();\n+        \t}\r\n        this.runningState = STATE_STOPPED;\n    }\n"],"patch3-Lang-55-Jaid-plausible.patch":["0","    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n+    \tif((this.runningState > 0) == true){\r\n+    \t\treturn;\r\n+    \t\t}\r\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }\n"],"patch1-Chart-5-RSRepair-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n+            this.data.add(new XYDataItem(x, y));\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-AVATAR-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value.\r\n     * @param y  the y-value.\r\n     *\r\n     * @return The item that was overwritten, if any.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public XYDataItem addOrUpdate(double x, double y) {\r\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(y), new Double(y));\n    }\r\n"],"patch1-Chart-5-Kali-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n+            if (false) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-Arja-plusible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n-            // check if this addition will exceed the maximum item count...\n+            this.data.add(new XYDataItem(x, y));\n+            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-kPAR-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n+            if ((index >= 0 && !this.allowDuplicateXValues)) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-TBar-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value.\r\n     * @param y  the y-value.\r\n     *\r\n     * @return The item that was overwritten, if any.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public XYDataItem addOrUpdate(double x, double y) {\r\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(getItemCount()), new Double(y));\n    }\r\n"],"patch1-Chart-5-jKali-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n+            if (false) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-DynaMoth-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n+            if (false) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-jGenProg-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n+            if (this.autoSort) {                 add(x, y, true);\n+\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Chart-5-Nopol-plausible.patch":["0","    /**\r\n     * Adds or updates an item in the series and sends a\r\n     * {@link SeriesChangeEvent} to all registered listeners.\r\n     *\r\n     * @param x  the x-value (<code>null</code> not permitted).\r\n     * @param y  the y-value (<code>null</code> permitted).\r\n     *\r\n     * @return A copy of the overwritten data item, or <code>null</code> if no\r\n     *         item was overwritten.\r\n     */\r\n    public XYDataItem addOrUpdate(Number x, Number y) {\r\n        if (x == null) {\r\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n        }\r\n\r\n        // if we get to here, we know that duplicate X values are not permitted\r\n        XYDataItem overwritten = null;\r\n        int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n            XYDataItem existing = (XYDataItem) this.data.get(index);\r\n            try {\r\n                overwritten = (XYDataItem) existing.clone();\r\n            }\r\n            catch (CloneNotSupportedException e) {\r\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n            }\r\n            existing.setY(y);\r\n        }\r\n        else {\r\n            // if the series is sorted, the negative index is a result from\r\n            // Collections.binarySearch() and tells us where to insert the\r\n            // new item...otherwise it will be just -1 and we should just\r\n            // append the value to the list...\r\n-            if (this.autoSort) {\n+            if (overwritten!=null) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\r\n            }\r\n            else {\r\n                this.data.add(new XYDataItem(x, y));\r\n            }\r\n            // check if this addition will exceed the maximum item count...\r\n            if (getItemCount() > this.maximumItemCount) {\r\n                this.data.remove(0);\r\n            }\r\n        }\r\n        fireSeriesChanged();\r\n        return overwritten;\r\n    }\r\n"],"patch1-Lang-51-kPAR-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if ((ch == 'y') || !(ch == 'Y')) {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-51-Jaid-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n+                if(((ch == 'Y') == (str == null)) == true){\r\n+                \treturn ch == 'T';\r\n+                \t}\r\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch2-Lang-51-Jaid-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n+                if((ch == 'Y' || str.isEmpty()) == false){\r\n+                \treturn str == null;\r\n+                \t}\r\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-51-Nopol-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (str!=null) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-51-TBar-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if (ch<='y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-51-DynaMoth-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (true) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch2-Lang-51-Jaid.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n+                if((ch == 'y') == false){\r\n+                \treturn ch == 'Y';\r\n+\r\n+                \t}\r\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch3-Lang-51-Jaid-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n+                if((ch == 'y' || str.isEmpty()) == false){\r\n+                \treturn ch == 'Y';\r\n+                \t} \r\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n+                \r\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-51-AVATAR-plausible.patch":["0","    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n-                if (ch == 'Y') {\n-                    return \n+                return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n-                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n"],"patch1-Lang-50-SimFix-plausible.patch":["0","    /**\n     * <p>Gets a date/time formatter instance using the specified style,\n     * time zone and locale.</p>\n     * \n     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n     * @param timeZone  optional time zone, overrides time zone of\n     *  formatted date\n     * @param locale  optional locale, overrides system locale\n     * @return a localized standard date/time formatter\n     * @throws IllegalArgumentException if the Locale has no date/time\n     *  pattern defined\n     */\n    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n            Locale locale) {\n\n        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n        if (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n        if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\n        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n+                if(locale!=null){\n+                    key=new Pair(key,locale);\n+                }\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                        locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateTimeInstanceCache.put(key, format);\n\n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return format;\n    }\n"],"patch1-Chart-1-Arja-plusible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\n-            return result;\n-        }\n+        setPlot(plot);\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch2-Chart-1-Jaid-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if ((index > dataset.getRowCount()) != false && dataset != null) {\r\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch2-Chart-1-SequenceR.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if((dataset!=null)&&(index!=0)){\r\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-Jaid-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n        if (dataset != null) {\r\n+        \t\tif(!((null == dataset) == false)){\r\n            return result;\r\n        }\r\n+        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-Kali-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\n+        if (false) {\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-GenProg-plausible.patch":["0","    /**\r\n     * Returns a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The axis (<code>null</code> possible).\r\n     */\r\n    public ValueAxis getRangeAxis(int index) {\r\n        ValueAxis result = null;\r\n        if (index < this.rangeAxes.size()) {\r\n            result = (ValueAxis) this.rangeAxes.get(index);\r\n        }\r\n        if (result == null) {\r\n-            Plot parent = getParent();\n+            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n+\t\t\tPlot parent = getParent();\n            if (parent instanceof CategoryPlot) {\r\n                CategoryPlot cp = (CategoryPlot) parent;\r\n                result = cp.getRangeAxis(index);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-jKali-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\n+        if (false) {\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch3-Chart-1-SequenceR.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if((dataset!=null)&&(!(dataset.equals(dataset)))){\r\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch2-Chart-1-SketchFix-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n        if (dataset != null) {\r\n+        \tif(false) {\r\n            return result;\r\n        }\r\n+        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-SketchFix-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) {\r\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-1-DynaMoth-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\n-            return result;\n+        if (false) {\n+            if (dataset != null) {\n+                return result;\n+            }\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch3-Chart-1-Jaid-plausible.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n        if (dataset != null) {\r\n+        \tif(!((result == getLegendItemToolTipGenerator()) == false)){\r\n            return result;\r\n        }\r\n+        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch4-Chart-1-SequenceR.patch":["0","    /**\r\n     * Returns a (possibly empty) collection of legend items for the series\r\n     * that this renderer is responsible for drawing.\r\n     *\r\n     * @return The legend item collection (never <code>null</code>).\r\n     *\r\n     * @see #getLegendItem(int, int)\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        if (this.plot == null) {\r\n            return result;\r\n        }\r\n        int index = this.plot.getIndexOf(this);\r\n        CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if((dataset!=null)&&(index> 0)){\r\n            return result;\r\n        }\r\n        int seriesCount = dataset.getRowCount();\r\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n            for (int i = 0; i < seriesCount; i++) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = seriesCount - 1; i >= 0; i--) {\r\n                if (isSeriesVisibleInLegend(i)) {\r\n                    LegendItem item = getLegendItem(index, i);\r\n                    if (item != null) {\r\n                        result.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-7-jMutRepair-plausible.patch":["0","    /**\r\n     * Update the index values for the maximum and minimum bounds.\r\n     * \r\n     * @param period  the time period.\r\n     * @param index  the index of the time period.\r\n     */\r\n    private void updateBounds(TimePeriod period, int index) {\r\n        \r\n        long start = period.getStart().getTime();\r\n        long end = period.getEnd().getTime();\r\n        long middle = start + ((end - start) / 2);\r\n\r\n        if (this.minStartIndex >= 0) {\r\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start < minStart) {\r\n                this.minStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minStartIndex = index;\r\n        }\r\n        \r\n        if (this.maxStartIndex >= 0) {\r\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start > maxStart) {\r\n                this.maxStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxStartIndex = index;\r\n        }\r\n        \r\n-        if (this.minMiddleIndex >= 0) {\n+        if (this.minMiddleIndex == 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long minMiddle = s + (e - s) / 2;\r\n            if (middle < minMiddle) {\r\n                this.minMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) / 2;\r\n            if (middle > maxMiddle) {\r\n                this.maxMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.minEndIndex >= 0) {\r\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end < minEnd) {\r\n                this.minEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minEndIndex = index;\r\n        }\r\n       \r\n        if (this.maxEndIndex >= 0) {\r\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end > maxEnd) {\r\n                this.maxEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxEndIndex = index;\r\n        }\r\n        \r\n    }\r\n"],"patch1-Chart-7-jGenProg-plausible.patch":["0","    /**\r\n     * Returns the index of the time period with the maximum middle \r\n     * milliseconds.\r\n     * \r\n     * @return The index.\r\n     */\r\n    public int getMaxMiddleIndex() {\r\n-        return this.maxMiddleIndex;\n+        return this.maxEndIndex;\n    }\r\n"],"patch1-Chart-7-Arja-plusible.patch":["0","    /**\r\n     * Update the index values for the maximum and minimum bounds.\r\n     * \r\n     * @param period  the time period.\r\n     * @param index  the index of the time period.\r\n     */\r\n    private void updateBounds(TimePeriod period, int index) {\r\n        \r\n        long start = period.getStart().getTime();\r\n        long end = period.getEnd().getTime();\r\n        long middle = start + ((end - start) / 2);\r\n\r\n        if (this.minStartIndex >= 0) {\r\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start < minStart) {\r\n                this.minStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minStartIndex = index;\r\n        }\r\n        \r\n        if (this.maxStartIndex >= 0) {\r\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start > maxStart) {\r\n                this.maxStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxStartIndex = index;\r\n        }\r\n        \r\n        if (this.minMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long minMiddle = s + (e - s) / 2;\r\n            if (middle < minMiddle) {\r\n                this.minMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) / 2;\r\n            if (middle > maxMiddle) {\r\n                this.maxMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.minEndIndex >= 0) {\r\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end < minEnd) {\r\n-                this.minEndIndex = index;           \n+                this.data.remove(index);\n+                this.minEndIndex = index;           \n            }\r\n        }\r\n        else {\r\n            this.minEndIndex = index;\r\n        }\r\n       \r\n        if (this.maxEndIndex >= 0) {\r\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end > maxEnd) {\r\n                this.maxEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxEndIndex = index;\r\n        }\r\n        \r\n    }\r\n"],"patch1-Chart-7-AVATAR-plausible.patch":["0","    /**\r\n     * Returns the index of the time period with the maximum middle \r\n     * milliseconds.\r\n     * \r\n     * @return The index.\r\n     */\r\n    public int getMaxMiddleIndex() {\r\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n    }\r\n"],"patch1-Chart-7-TBar-plausible.patch":["0","    /**\r\n     * Returns the index of the time period with the maximum middle \r\n     * milliseconds.\r\n     * \r\n     * @return The index.\r\n     */\r\n    public int getMaxMiddleIndex() {\r\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n+\n    }\r\n"],"patch1-Chart-7-FixMiner-plausible.patch":["0","    /**\r\n     * Update the index values for the maximum and minimum bounds.\r\n     * \r\n     * @param period  the time period.\r\n     * @param index  the index of the time period.\r\n     */\r\n    private void updateBounds(TimePeriod period, int index) {\r\n        \r\n        long start = period.getStart().getTime();\r\n        long end = period.getEnd().getTime();\r\n        long middle = start + ((end - start) / 2);\r\n\r\n        if (this.minStartIndex >= 0) {\r\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start < minStart) {\r\n                this.minStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minStartIndex = index;\r\n        }\r\n        \r\n        if (this.maxStartIndex >= 0) {\r\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start > maxStart) {\r\n                this.maxStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxStartIndex = index;\r\n        }\r\n        \r\n        if (this.minMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()\n                .getTime();\r\n            long minMiddle = s + (e - s) / 2;\r\n            if (middle < minMiddle) {\r\n                this.minMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) / 2;\r\n            if (middle > maxMiddle) {\r\n                this.maxMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.minEndIndex >= 0) {\r\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end < minEnd) {\r\n                this.minEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minEndIndex = index;\r\n        }\r\n       \r\n        if (this.maxEndIndex >= 0) {\r\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end > maxEnd) {\r\n                this.maxEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxEndIndex = index;\r\n        }\r\n        \r\n    }\r\n"],"patch1-Chart-7-kPAR-plausible.patch":["0","    /**\r\n     * Update the index values for the maximum and minimum bounds.\r\n     * \r\n     * @param period  the time period.\r\n     * @param index  the index of the time period.\r\n     */\r\n    private void updateBounds(TimePeriod period, int index) {\r\n        \r\n        long start = period.getStart().getTime();\r\n        long end = period.getEnd().getTime();\r\n        long middle = start + ((end - start) / 2);\r\n\r\n        if (this.minStartIndex >= 0) {\r\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start < minStart) {\r\n                this.minStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minStartIndex = index;\r\n        }\r\n        \r\n        if (this.maxStartIndex >= 0) {\r\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\r\n                .getStart().getTime();\r\n            if (start > maxStart) {\r\n                this.maxStartIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxStartIndex = index;\r\n        }\r\n        \r\n        if (this.minMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()\n                .getTime();\r\n            long minMiddle = s + (e - s) / 2;\r\n            if (middle < minMiddle) {\r\n                this.minMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) / 2;\r\n            if (middle > maxMiddle) {\r\n                this.maxMiddleIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxMiddleIndex = index;\r\n        }\r\n        \r\n        if (this.minEndIndex >= 0) {\r\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end < minEnd) {\r\n                this.minEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.minEndIndex = index;\r\n        }\r\n       \r\n        if (this.maxEndIndex >= 0) {\r\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            if (end > maxEnd) {\r\n                this.maxEndIndex = index;           \r\n            }\r\n        }\r\n        else {\r\n            this.maxEndIndex = index;\r\n        }\r\n        \r\n    }\r\n"],"patch3-Chart-9-Jaid-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the first time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     * @param end  the last time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     *\r\n     * @return A time series containing a copy of this time series from start\r\n     *         until end.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\r\n        throws CloneNotSupportedException {\r\n\r\n        if (start == null) {\r\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n        }\r\n        if (end == null) {\r\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n        }\r\n        if (start.compareTo(end) > 0) {\r\n            throw new IllegalArgumentException(\r\n                    \"Requires start on or before end.\");\r\n        }\r\n        boolean emptyRange = false;\r\n        int startIndex = getIndex(start);\r\n        if (startIndex < 0) {\r\n            startIndex = -(startIndex + 1);\r\n            if (startIndex == this.data.size()) {\r\n                emptyRange = true;  // start is after last data item\r\n            }\r\n        }\r\n        int endIndex = getIndex(end);\r\n        if (endIndex < 0) {             // end period is not in original series\r\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\r\n        }\r\n        if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }\r\n+        if((endIndex > startIndex) == false){\r\n+        \tstartIndex=endIndex;\r\n+        \t}\r\n        if (emptyRange) {\r\n            TimeSeries copy = (TimeSeries) super.clone();\r\n            copy.data = new java.util.ArrayList();\r\n            return copy;\r\n        }\r\n        else {\r\n            return createCopy(startIndex, endIndex);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-9-Jaid-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the first time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     * @param end  the last time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     *\r\n     * @return A time series containing a copy of this time series from start\r\n     *         until end.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\r\n        throws CloneNotSupportedException {\r\n\r\n        if (start == null) {\r\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n        }\r\n        if (end == null) {\r\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n        }\r\n        if (start.compareTo(end) > 0) {\r\n            throw new IllegalArgumentException(\r\n                    \"Requires start on or before end.\");\r\n        }\r\n        boolean emptyRange = false;\r\n        int startIndex = getIndex(start);\r\n        if (startIndex < 0) {\r\n            startIndex = -(startIndex + 1);\r\n            if (startIndex == this.data.size()) {\r\n                emptyRange = true;  // start is after last data item\r\n            }\r\n        }\r\n        int endIndex = getIndex(end);\r\n        if (endIndex < 0) {             // end period is not in original series\r\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\r\n        }\r\n+        if((startIndex == 1) == true){\r\n+        \treturn this;\r\n+\r\n+        \t}\r\n        if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }\r\n        if (emptyRange) {\r\n            TimeSeries copy = (TimeSeries) super.clone();\r\n            copy.data = new java.util.ArrayList();\r\n            return copy;\r\n        }\r\n        else {\r\n            return createCopy(startIndex, endIndex);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-9-Nopol-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end)\r\n        throws CloneNotSupportedException {\r\n\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n        if (end < start) {\r\n-            throw new IllegalArgumentException(\"Requires start <= end.\");\n+            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) {\n+                throw new IllegalArgumentException(\"Requires start <= end.\");\n+            }\n        }\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item\r\n                    = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"patch2-Chart-9-Jaid-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the first time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     * @param end  the last time period to copy (<code>null</code> not\r\n     *         permitted).\r\n     *\r\n     * @return A time series containing a copy of this time series from start\r\n     *         until end.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\r\n        throws CloneNotSupportedException {\r\n\r\n        if (start == null) {\r\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n        }\r\n        if (end == null) {\r\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n        }\r\n        if (start.compareTo(end) > 0) {\r\n            throw new IllegalArgumentException(\r\n                    \"Requires start on or before end.\");\r\n        }\r\n        boolean emptyRange = false;\r\n        int startIndex = getIndex(start);\r\n        if (startIndex < 0) {\r\n            startIndex = -(startIndex + 1);\r\n            if (startIndex == this.data.size()) {\r\n                emptyRange = true;  // start is after last data item\r\n            }\r\n        }\r\n        int endIndex = getIndex(end);\r\n        if (endIndex < 0) {             // end period is not in original series\r\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\r\n        }\r\n        if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }\r\n+        if((startIndex == 1) == true){\r\n+        \treturn this;\r\n+        \t}\r\n        if (emptyRange) {\r\n            TimeSeries copy = (TimeSeries) super.clone();\r\n            copy.data = new java.util.ArrayList();\r\n            return copy;\r\n        }\r\n        else {\r\n            return createCopy(startIndex, endIndex);\r\n        }\r\n\r\n    }\r\n"],"patch1-Math-15-TBar-plausible.patch":["0","    /**\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     */\n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n"],"patch1-Math-15-kPAR-plausible.patch":["0","    /**\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     */\n    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n"],"patch2-Closure-86-SequenceR.patch":["0","  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.isImmutableValue(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n"],"patch5-Closure-86-SequenceR.patch":["0","  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.evaluatesToLocalValue(value.getFirstChild());\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n"],"patch4-Closure-86-SequenceR.patch":["0","  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.isToStringMethodCall(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n"],"patch3-Closure-86-SequenceR.patch":["0","  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n"],"patch1-Math-18-Nopol-plausible.patch":["0","    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n+                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.checkFeasableCount == org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.iterations) {\n+                    hasFiniteBounds = true;\n+                }\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n"],"patch1-Math-95-AVATAR-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n-        return ret;\n+        return d;\n    }\n"],"patch1-Math-95-Arja-plausible.patch":["0","    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n        throws MathException {\n-        if (p == 0) {\n+        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n"],"patch1-Math-95-jGenProg-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n-        ret = d / (d - 2.0);\n+        ret = d / (d - 2.0);         ret = 0.0;\n        return ret;\n    }\n"],"patch1-Math-95-GenProg-plausible.patch":["0","    /**\n     * For this distribution, X, this method returns P(X &lt; x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n     * F-Distribution</a>, equation (4).</li>\n     * </ul>\n     * \n     * @param x the value at which the CDF is evaluated.\n     * @return CDF for this distribution. \n     * @throws MathException if the cumulative probability can not be\n     *            computed due to convergence or other numerical errors.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n            ret = 0.0;\n        } else {\n-            double n = getNumeratorDegreesOfFreedom();\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n"],"patch1-Math-95-TBar-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (d + 2.0);\n        return ret;\n    }\n"],"patch1-Math-95-Cardumen-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n-        double d = getDenominatorDegreesOfFreedom();\n+        double d = p - 2.0;\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }\n"],"patch1-Math-95-Kali-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n-        double d = getDenominatorDegreesOfFreedom();\n+        if (true)\n+            return 0;\n+        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }\n"],"patch1-Math-95-RSRepair-plausible.patch":["0","    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 1.0;\n        return ret;\n    }\n"],"patch1-Math-96-TBar-plausible.patch":["0","    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n"],"patch1-Math-97-ACS-plausible.patch":["0","    /**\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function \n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     */\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n+if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }\n"],"patch1-Lang-45-TBar-plausible.patch":["0","    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if ((upper < lower) && (upper != str.length())) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"],"patch1-Lang-45-kPAR-plausible.patch":["0","    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if ((upper < lower) && (upper != str.length())) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"],"patch1-Lang-45-Jaid-plausible.patch":["0","    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n+        if((lower > str.length()) == true){\r\n+        \tlower=str.length();\r\n+\r\n+        \t}else{\r\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n+        \t}\r\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"],"patch2-Lang-45-Jaid-plausible.patch":["0","    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n+        if((lower >= str.length()) == true){\r\n+        \tlower=str.length();\r\n+\r\n+        \t}else{\r\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n+        \t}\r\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"],"patch1-Lang-45-SimFix-plausible.patch":["0","    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if((lower+(upper-3))<lower){\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n"],"patch1-Lang-63-FixMiner-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end.add( newdiff, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-63-kPAR-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end.add( newdiff, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-63-SimFix-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n-        if (endValue < startValue) {\n+        if(endValue<field){\n            int newdiff = startValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-63-TBar-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = difference - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-63-AVATAR-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = endValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-63-DynaMoth-plausible.patch":["0","    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            if (false) {\n+                end.add( field, newdiff );\n+            }\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n"],"patch1-Lang-60-TBar-plausible.patch":["0","    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(int startIndex, int endIndex, int len) {\n-        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex);\n        size -= len;\n    }\n"],"patch1-Lang-60-SimFix.patch":["0","    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n+    // start of generated patch\n+        for(int i=0;i<size;i++){\n+          if(thisBuf[i]==ch){\n+            return true;\n+          }\n+        }\n+    // end of generated patch\n+    /* start of original code\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n+    end of original code*/\n        return false;\n    }\n"],"patch1-Math-70-SketchFix-plausible.patch":["0","    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\r\n    }\n"],"patch2-Math-70-SketchFix-plausible.patch":["0","    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\r\n    }\n"],"patch1-Math-71-jKali-plausible.patch":["0","    /**\n     * Construct an algorithm with given iteration count and accuracy.\n     *\n     * @param defaultAbsoluteAccuracy maximum absolute error\n     * @param defaultMaximalIterationCount maximum number of iterations\n     * @throws IllegalArgumentException if f is null or the\n     * defaultAbsoluteAccuracy is not valid\n     */\n    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }\n"],"patch1-Math-71-DynaMoth-plausible.patch":["0","  /** Set the initial step size.\n   * <p>This method allows the user to specify an initial positive\n   * step size instead of letting the integrator guess it by\n   * itself. If this method is not called before integration is\n   * started, the initial step size will be estimated by the\n   * integrator.</p>\n   * @param initialStepSize initial step size to use (must be positive even\n   * for backward integration ; providing a negative value or a value\n   * outside of the min/max step interval will lead the integrator to\n   * ignore the value and compute the initial step size by itself)\n   */\n  public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n+    if (false) {\n+      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+        initialStep = -1.0;\n+      } else {\n+        initialStep = initialStepSize;\n+      }\n    }\n  }\n"],"patch1-Lang-61-SimFix-plausible.patch":["0","    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n-        for (int i = startIndex; i < len; i++) {\n+        for(int i=startIndex;i<size;i++){\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n"],"patch2-Lang-61-Jaid-plausible.patch":["0","    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n-                if (str.charAt(j) != thisBuf[i + j]) {\n+            \tif (str.charAt(j) != thisBuf[i + j] || (i + j >= size()) == true) {\r\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n"],"patch1-Lang-61-Jaid-plausible.patch":["0","    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n-                if (str.charAt(j) != thisBuf[i + j]) {\n+            \tif (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) {\r\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n"],"patch1-Chart-24-Cardumen-plausible.patch":["0","    /**\r\n     * Returns a paint for the specified value.\r\n     * \r\n     * @param value  the value (must be within the range specified by the\r\n     *         lower and upper bounds for the scale).\r\n     * \r\n     * @return A paint for the specified value.\r\n     */\r\n    public Paint getPaint(double value) {\r\n        double v = Math.max(value, this.lowerBound);\r\n        v = Math.min(v, this.upperBound);\r\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((java.lang.Math.min(v, upperBound)) / (this.upperBound \n                - this.lowerBound) * 255.0);\r\n        return new Color(g, g, g);\r\n    }\r\n"],"patch1-Chart-25-Kali-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\r\n-        if (masd != null) {\n+        if (false) {\n            result = masd.getMean();\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-25-kPAR-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n-            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n+            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column);\n        if (masd != null) {\r\n            result = masd.getMean();\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-25-RSRepair-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\r\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n        return result;\r\n    }\r\n"],"patch1-Chart-25-GenProg-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\r\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n        return result;\r\n    }\r\n"],"patch1-Chart-25-SimFix-plausible.patch":["0","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n        if (orientation == PlotOrientation.HORIZONTAL) {\r\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \r\n                    rangeAxis, statData, row, column);\r\n        }\r\n-        else if (orientation == PlotOrientation.VERTICAL) {\n+        if (orientation == PlotOrientation.HORIZONTAL) {\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \r\n                    statData, row, column);\r\n        }\r\n    }\r\n"],"patch1-Chart-25-FixMiner-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n-            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n+            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column);\n        if (masd != null) {\r\n            result = masd.getMean();\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-25-jKali-plausible.patch":["0","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n    }\r\n"],"patch1-Chart-25-jGenProg-plausible.patch":["0","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n+\n+\n+\n+\n+\n+\n+\n+\n    }\r\n"],"patch1-Chart-25-jMutRepair-plausible.patch":["0","    /**\r\n     * Returns the mean value for an item.\r\n     *\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     *\r\n     * @return The mean value.\r\n     */\r\n    public Number getMeanValue(int row, int column) {\r\n        Number result = null;\r\n        MeanAndStandardDeviation masd \r\n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\r\n-        if (masd != null) {\n+        if (masd == null) {\n            result = masd.getMean();\r\n        }\r\n        return result;\r\n    }\r\n"],"patch1-Chart-25-Nopol-plausible.patch":["0","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (3 == 0) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n        }\r\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n    }\r\n"],"patch1-Chart-25-Arja-plusible.patch":["0","    /**\r\n     * Draws an item for a plot with a horizontal orientation.\r\n     * \r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param dataset  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     */\r\n    protected void drawHorizontalItem(Graphics2D g2,\r\n                                      CategoryItemRendererState state,\r\n                                      Rectangle2D dataArea,\r\n                                      CategoryPlot plot,\r\n                                      CategoryAxis domainAxis,\r\n                                      ValueAxis rangeAxis,\r\n                                      StatisticalCategoryDataset dataset,\r\n                                      int row,\r\n                                      int column) {\r\n                                     \r\n-        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n+        if (this.errorIndicatorPaint != null) {\n+                                                g2.setPaint(this.errorIndicatorPaint);\n+                                        } else {\n+                                               g2.setPaint(getItemPaint(row, column));\n+                                        }\n+        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \r\n        // BAR Y\r\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \r\n                dataArea, xAxisLocation);\r\n\r\n        int seriesCount = getRowCount();\r\n        int categoryCount = getColumnCount();\r\n        if (seriesCount > 1) {\r\n            double seriesGap = dataArea.getHeight() * getItemMargin()\r\n                               / (categoryCount * (seriesCount - 1));\r\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\r\n        }\r\n        else {\r\n            rectY = rectY + row * state.getBarWidth();\r\n        }\r\n\r\n        // BAR X\r\n        Number meanValue = dataset.getMeanValue(row, column);\r\n\r\n        double value = meanValue.doubleValue();\r\n        double base = 0.0;\r\n        double lclip = getLowerClip();\r\n        double uclip = getUpperClip();\r\n\r\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\r\n            if (value >= uclip) {\r\n                return; // bar is not visible\r\n            }\r\n            base = uclip;\r\n            if (value <= lclip) {\r\n                value = lclip;\r\n            }\r\n-        }\n-        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n-            if (value >= uclip) {\n-                value = uclip;\n-            }\n-            else {\n-                if (value <= lclip) {\n-                    value = lclip;\n-                }\n-            }\n-        }\n-        else { // cases 9, 10, 11 and 12\n-            if (value <= lclip) {\n-                return; // bar is not visible\n-            }\n-            base = getLowerClip();\n-            if (value >= uclip) {\n-               value = uclip;\n-            }\n-        }\n+        } else {\n+            rectY = rectY + row * state.getBarWidth();\n+            if (lclip <= 0.0) {\n+                if (value >= uclip) {\n+                    value = uclip;\n+                } else {\n+                    if (value <= lclip) {\n+                        value = lclip;\n+                    }\n+                }\n+            } else {\n+                if (value <= lclip) {\n+                    return;\n+                }\n+                base = getLowerClip();\n+                if (value >= uclip) {\n+                    value = uclip;\n+                }\n+            }\n+        }\n\r\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\r\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\r\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \r\n                yAxisLocation);\r\n        double rectX = Math.min(transY2, transY1);\r\n\r\n        double rectHeight = state.getBarWidth();\r\n        double rectWidth = Math.abs(transY2 - transY1);\r\n\r\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \r\n                rectHeight);\r\n        Paint seriesPaint = getItemPaint(row, column);\r\n        g2.setPaint(seriesPaint);\r\n        g2.fill(bar);\r\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\r\n            g2.setStroke(getItemStroke(row, column));\r\n            g2.setPaint(getItemOutlinePaint(row, column));\r\n            g2.draw(bar);\r\n        }\r\n\r\n        // standard deviation lines\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                    + valueDelta, dataArea, yAxisLocation);\r\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                    - valueDelta, dataArea, yAxisLocation);\r\n\r\n            if (this.errorIndicatorStroke != null) {\r\n                g2.setStroke(this.errorIndicatorStroke);\r\n            }\r\n            else {\r\n                g2.setStroke(getItemOutlineStroke(row, column));\r\n            }\r\n            if (this.errorIndicatorPaint != null) {\r\n                g2.setPaint(this.errorIndicatorPaint);  \r\n            }\r\n            else {\r\n                g2.setPaint(getItemOutlinePaint(row, column));   \r\n            }\r\n        \r\n            Line2D line = null;\r\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \r\n                                     highVal, rectY + rectHeight / 2.0d);\r\n            g2.draw(line);\r\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \r\n                                     highVal, rectY + rectHeight * 0.75);\r\n            g2.draw(line);\r\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                     lowVal, rectY + rectHeight * 0.75);\r\n            g2.draw(line);\r\n        \r\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                column);\r\n        if (generator != null && isItemLabelVisible(row, column)) {\r\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \r\n                    (value < 0.0));\r\n        }        \r\n\r\n        // add an item entity, if this information is being collected\r\n        EntityCollection entities = state.getEntityCollection();\r\n        if (entities != null) {\r\n            addItemEntity(entities, dataset, row, column, bar);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-25-DynaMoth-plausible.patch":["0","    /**\r\n     * Draws the bar with its standard deviation line range for a single \r\n     * (series, category) data item.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param state  the renderer state.\r\n     * @param dataArea  the data area.\r\n     * @param plot  the plot.\r\n     * @param domainAxis  the domain axis.\r\n     * @param rangeAxis  the range axis.\r\n     * @param data  the data.\r\n     * @param row  the row index (zero-based).\r\n     * @param column  the column index (zero-based).\r\n     * @param pass  the pass index.\r\n     */\r\n    public void drawItem(Graphics2D g2,\r\n                         CategoryItemRendererState state,\r\n                         Rectangle2D dataArea,\r\n                         CategoryPlot plot,\r\n                         CategoryAxis domainAxis,\r\n                         ValueAxis rangeAxis,\r\n                         CategoryDataset data,\r\n                         int row,\r\n                         int column,\r\n                         int pass) {\r\n\r\n        // defensive check\r\n        if (!(data instanceof StatisticalCategoryDataset)) {\r\n            throw new IllegalArgumentException(\r\n                \"Requires StatisticalCategoryDataset.\");\r\n        }\r\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\r\n\r\n        PlotOrientation orientation = plot.getOrientation();\r\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (false) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n        }\r\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n    }\r\n"],"patch1-Chart-25-AVATAR-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Chart-25-TBar-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Chart-26-TBar-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n-        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n+        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n        if (b1 || b2) {\r\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-26-jMutRepair-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n-        if (b1 || b2) {\n+        if ((!b1) || b2) {\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch2-Chart-26-Jaid-plausible.patch":["0","    /**\r\n     * Draws the axis label.\r\n     *\r\n     * @param label  the label text.\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param dataArea  the area inside the axes.\r\n     * @param edge  the location of the axis.\r\n     * @param state  the axis state (<code>null</code> not permitted).\r\n     * @param plotState  the plot state (<code>null</code> permitted).\r\n     *\r\n     * @return Information about the axis.\r\n     */\r\n    protected AxisState drawLabel(String label, Graphics2D g2, \r\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \r\n            AxisState state, PlotRenderingInfo plotState) {\r\n\r\n        // it is unlikely that 'state' will be null, but check anyway...\r\n        if (state == null) {\r\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\r\n        }\r\n        \r\n        if ((label == null) || (label.equals(\"\"))) {\r\n            return state;\r\n        }\r\n\r\n        Font font = getLabelFont();\r\n        RectangleInsets insets = getLabelInsets();\r\n        g2.setFont(font);\r\n        g2.setPaint(getLabelPaint());\r\n        FontMetrics fm = g2.getFontMetrics();\r\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\r\n        Shape hotspot = null;\r\n        \r\n        if (edge == RectangleEdge.TOP) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle(), labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) dataArea.getCenterX();\r\n            float labely = (float) (state.getCursor() - insets.getBottom() \r\n                    - h / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \r\n                    + insets.getBottom());\r\n        }\r\n        else if (edge == RectangleEdge.BOTTOM) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle(), labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) dataArea.getCenterX();\r\n            float labely = (float) (state.getCursor() + insets.getTop() \r\n                    + h / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \r\n                    + insets.getBottom());\r\n        }\r\n        else if (edge == RectangleEdge.LEFT) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) (state.getCursor() - insets.getRight() \r\n                    - w / 2.0);\r\n            float labely = (float) dataArea.getCenterY();\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \r\n                    TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \r\n                    + insets.getRight());\r\n        }\r\n        else if (edge == RectangleEdge.RIGHT) {\r\n\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle() + Math.PI / 2.0, \r\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) (state.getCursor() \r\n                            + insets.getLeft() + w / 2.0);\r\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \r\n                    / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \r\n                    TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \r\n                    + insets.getRight());\r\n\r\n        }\r\n-        if (plotState != null && hotspot != null) {\r\n+        if ((hotspot != null && plotState != null) != true && plotState != null && hotspot != null) {\r\n            ChartRenderingInfo owner = plotState.getOwner();\r\n                EntityCollection entities = owner.getEntityCollection();\r\n                if (entities != null) {\r\n                    entities.add(new AxisLabelEntity(this, hotspot, \r\n                            this.labelToolTip, this.labelURL));\r\n                }\r\n        }\r\n        return state;\r\n\r\n    }\r\n"],"patch1-Chart-26-Jaid-plausible.patch":["0","    /**\r\n     * Draws the axis label.\r\n     *\r\n     * @param label  the label text.\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param dataArea  the area inside the axes.\r\n     * @param edge  the location of the axis.\r\n     * @param state  the axis state (<code>null</code> not permitted).\r\n     * @param plotState  the plot state (<code>null</code> permitted).\r\n     *\r\n     * @return Information about the axis.\r\n     */\r\n    protected AxisState drawLabel(String label, Graphics2D g2, \r\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \r\n            AxisState state, PlotRenderingInfo plotState) {\r\n\r\n        // it is unlikely that 'state' will be null, but check anyway...\r\n        if (state == null) {\r\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\r\n        }\r\n        \r\n        if ((label == null) || (label.equals(\"\"))) {\r\n            return state;\r\n        }\r\n\r\n        Font font = getLabelFont();\r\n        RectangleInsets insets = getLabelInsets();\r\n        g2.setFont(font);\r\n        g2.setPaint(getLabelPaint());\r\n        FontMetrics fm = g2.getFontMetrics();\r\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\r\n        Shape hotspot = null;\r\n        \r\n        if (edge == RectangleEdge.TOP) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle(), labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) dataArea.getCenterX();\r\n            float labely = (float) (state.getCursor() - insets.getBottom() \r\n                    - h / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \r\n                    + insets.getBottom());\r\n        }\r\n        else if (edge == RectangleEdge.BOTTOM) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle(), labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) dataArea.getCenterX();\r\n            float labely = (float) (state.getCursor() + insets.getTop() \r\n                    + h / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \r\n                    + insets.getBottom());\r\n        }\r\n        else if (edge == RectangleEdge.LEFT) {\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \r\n                    labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) (state.getCursor() - insets.getRight() \r\n                    - w / 2.0);\r\n            float labely = (float) dataArea.getCenterY();\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \r\n                    TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \r\n                    + insets.getRight());\r\n        }\r\n        else if (edge == RectangleEdge.RIGHT) {\r\n\r\n            AffineTransform t = AffineTransform.getRotateInstance(\r\n                    getLabelAngle() + Math.PI / 2.0, \r\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\r\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n            labelBounds = rotatedLabelBounds.getBounds2D();\r\n            float w = (float) labelBounds.getWidth();\r\n            float h = (float) labelBounds.getHeight();\r\n            float labelx = (float) (state.getCursor() \r\n                            + insets.getLeft() + w / 2.0);\r\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \r\n                    / 2.0);\r\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \r\n                    TextAnchor.CENTER);\r\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n                    labely - h / 2.0f, w, h);\r\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \r\n                    + insets.getRight());\r\n\r\n        }\r\n+        hotspot=null;\r\n        if (plotState != null && hotspot != null) {\r\n            ChartRenderingInfo owner = plotState.getOwner();\r\n                EntityCollection entities = owner.getEntityCollection();\r\n                if (entities != null) {\r\n                    entities.add(new AxisLabelEntity(this, hotspot, \r\n                            this.labelToolTip, this.labelURL));\r\n                }\r\n        }\r\n        return state;\r\n\r\n    }\r\n"],"patch1-Chart-26-kPAR-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n-        if (b1 || b2) {\n+        if (b1 || (getRenderer() != null)) {\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-26-AVATAR-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n-        if (b1 || b2) {\n+        if (this.rangeGridlinesVisible || b2) {\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-26-FixMiner-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n-        if (b1 || b2) {\n+        if (b1 || (getRenderer() != null)) {\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch1-Chart-26-Kali-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should \r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly \r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, \r\n                     Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo state) {\r\n\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n        if (b1 || b2) {\r\n            return;\r\n        }\r\n\r\n        // record the plot area...\r\n        if (state == null) {\r\n-            // if the incoming state is null, no information will be passed\n+            if (true)\n+                return;\n+            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n\r\n        state.setDataArea(dataArea);\r\n\r\n        // if there is a renderer, it draws the background, otherwise use the \r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n       \r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n\r\n        drawDomainGridlines(g2, dataArea);\r\n\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\r\n                        .get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        \r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }        \r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n\r\n        // now render data items...\r\n        boolean foundData = false;\r\n\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(\r\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            for (int i = 0; i < this.datasets.size(); i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n        }\r\n        else {  // DatasetRenderingOrder.REVERSE\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;   \r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n\r\n        // draw the annotations (if any)...\r\n        drawAnnotations(g2, dataArea);\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \r\n                    getRangeCrosshairValue(), getRangeAxis(),\r\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        }\r\n        else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n\r\n    }\r\n"],"patch1-Closure-50-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Math-69-Nopol-plausible.patch":["0","    /**\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n-        for (int i = 0; i < nVars; i++) {\n-            for (int j = 0; j < i; j++) {\n-              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n-              outMatrix.setEntry(i, j, corr);\n-              outMatrix.setEntry(j, i, corr);\n+        if ((nVars) != (2)) {\n+            for (int i = 0; i < nVars; i++) {\n+                for (int j = 0; j < i; j++) {\n+                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n+                    outMatrix.setEntry(i, j, corr);\n+                    outMatrix.setEntry(j, i, corr);\n+                }\n+                outMatrix.setEntry(i, i, 1d);\n            }\n-            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }\n"],"patch1-Math-69-SimFix-plausible.patch":["0","    /**\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n-                if (i == j) {\n-                    out[i][j] = 0d;\n+                if(i==j&&i<nVars){\n+                    out[i][j]=0.0;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n"],"patch1-Closure-55-GenProg-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n-    // Accumulate possible reductions in the reduction multi map.  They\n-    // will be applied in the loop below.\n-    NodeTraversal.traverse(compiler, root,\n-                           new ReductionGatherer(reducers, reductionMap));\n-\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n"],"patch1-Closure-55-Kali-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n-      if (helperCode == null) {\n+      if (true) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n"],"patch1-Closure-55-Arja-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n-        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n"],"patch1-Closure-55-RSRepair-plausible.patch":["0","  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n-\n-      // Compare estimated savings against the helper cost.  Apply\n-      // reductions if doing so will result in some savings.\n-      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n-        for (Reduction reduction : reductions) {\n-          reduction.apply();\n-        }\n-\n-        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n-        addingRoot.addChildrenToFront(helperCode);\n-        compiler.reportCodeChange();\n-      }\n    }\n  }\n"],"patch1-Closure-59-GenProg-plausible.patch":["0","  public void setOptionsForWarningLevel(CompilerOptions options) {\n    switch (this) {\n      case QUIET:\n        silenceAllWarnings(options);\n        break;\n      case DEFAULT:\n        addDefaultWarnings(options);\n        break;\n      case VERBOSE:\n-        addVerboseWarnings(options);\n+        boolean valid = false;\n        break;\n      default:\n        throw new RuntimeException(\"Unknown warning level.\");\n    }\n  }\n"],"patch1-Closure-59-Arja-plausible.patch":["0","  public void setOptionsForWarningLevel(CompilerOptions options) {\n    switch (this) {\n      case QUIET:\n        silenceAllWarnings(options);\n        break;\n      case DEFAULT:\n        addDefaultWarnings(options);\n        break;\n      case VERBOSE:\n-        addVerboseWarnings(options);\n+        ;\n        break;\n      default:\n        throw new RuntimeException(\"Unknown warning level.\");\n    }\n  }\n"],"patch1-Closure-59-Kali-plausible.patch":["0","  @Override\n  protected List<PassFactory> getChecks() {\n    List<PassFactory> checks = Lists.newArrayList();\n\n    if (options.closurePass) {\n      checks.add(closureGoogScopeAliases);\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.MAPPED) {\n        checks.add(nameMappedAnonymousFunctions);\n      } else if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.UNMAPPED) {\n        checks.add(nameUnmappedAnonymousFunctions);\n      }\n      return checks;\n    }\n\n    if (options.checkSuspiciousCode ||\n        options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n      checks.add(suspiciousCode);\n    }\n\n    if (options.checkControlStructures)  {\n      checks.add(checkControlStructures);\n    }\n\n    if (options.checkRequires.isOn()) {\n      checks.add(checkRequires);\n    }\n\n    if (options.checkProvides.isOn()) {\n      checks.add(checkProvides);\n    }\n\n    // The following passes are more like \"preprocessor\" passes.\n    // It's important that they run before most checking passes.\n    // Perhaps this method should be renamed?\n    if (options.generateExports) {\n      checks.add(generateExports);\n    }\n\n    if (options.exportTestFunctions) {\n      checks.add(exportTestFunctions);\n    }\n\n    if (options.closurePass) {\n      checks.add(closurePrimitives.makeOneTimePass());\n    }\n\n    if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n      checks.add(closureCheckGetCssName);\n    }\n\n    if (options.syntheticBlockStartMarker != null) {\n      // This pass must run before the first fold constants pass.\n      checks.add(createSyntheticBlocks);\n    }\n\n    checks.add(checkVars);\n    if (options.computeFunctionSideEffects) {\n      checks.add(checkRegExp);\n    }\n\n    if (options.checkShadowVars.isOn()) {\n      checks.add(checkShadowVars);\n    }\n\n    if (options.aggressiveVarCheck.isOn()) {\n      checks.add(checkVariableReferences);\n    }\n\n    // This pass should run before types are assigned.\n    if (options.processObjectPropertyString) {\n      checks.add(objectPropertyStringPreprocess);\n    }\n\n    if (options.checkTypes || options.inferTypes) {\n      checks.add(resolveTypes.makeOneTimePass());\n      checks.add(inferTypes.makeOneTimePass());\n      if (options.checkTypes) {\n        checks.add(checkTypes.makeOneTimePass());\n      } else {\n        checks.add(inferJsDocInfo.makeOneTimePass());\n      }\n    }\n\n    if (options.checkUnreachableCode.isOn() ||\n        (options.checkTypes && options.checkMissingReturn.isOn())) {\n      checks.add(checkControlFlow);\n    }\n\n    // CheckAccessControls only works if check types is on.\n    if (options.checkTypes &&\n        (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n         || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {\n-      checks.add(checkAccessControls);\n+      if (true)\n+            return null;\n+   checks.add(checkAccessControls);\n    }\n\n    if (options.checkGlobalNamesLevel.isOn()) {\n      checks.add(checkGlobalNames);\n    }\n\n    checks.add(checkStrictMode);\n\n    // Replace 'goog.getCssName' before processing defines but after the\n    // other checks have been done.\n    if (options.closurePass) {\n      checks.add(closureReplaceGetCssName);\n    }\n\n    // i18n\n    // If you want to customize the compiler to use a different i18n pass,\n    // you can create a PassConfig that calls replacePassFactory\n    // to replace this.\n    checks.add(options.messageBundle != null ?\n        replaceMessages : createEmptyPass(\"replaceMessages\"));\n\n    if (options.getTweakProcessing().isOn()) {\n      checks.add(processTweaks);\n    }\n\n    // Defines in code always need to be processed.\n    checks.add(processDefines);\n\n    if (options.instrumentationTemplate != null ||\n        options.recordFunctionInformation) {\n      checks.add(computeFunctionNames);\n    }\n\n    if (options.nameReferenceGraphPath != null &&\n        !options.nameReferenceGraphPath.isEmpty()) {\n      checks.add(printNameReferenceGraph);\n    }\n\n    if (options.nameReferenceReportPath != null &&\n        !options.nameReferenceReportPath.isEmpty()) {\n      checks.add(printNameReferenceReport);\n    }\n\n    assertAllOneTimePasses(checks);\n    return checks;\n  }\n"],"patch1-Closure-59-RSRepair-plausible.patch":["0","  /**\n   * Add all the check pass that are possibly relevant to a non googler.\n   * @param options The CompilerOptions object to set the options on.\n   */\n  private static void addVerboseWarnings(CompilerOptions options) {\n    addDefaultWarnings(options);\n\n    // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n    options.checkSuspiciousCode = true;\n-    options.checkGlobalThisLevel = CheckLevel.WARNING;\n    options.checkSymbols = true;\n    options.checkMissingReturn = CheckLevel.WARNING;\n\n    // checkTypes has the side-effect of asserting that the\n    // correct number of arguments are passed to a function.\n    // Because the CodingConvention used with the web service does not provide a\n    // way for optional arguments to be specified, these warnings may result in\n    // false positives.\n    options.checkTypes = true;\n    options.checkGlobalNamesLevel = CheckLevel.WARNING;\n    options.aggressiveVarCheck = CheckLevel.WARNING;\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n    options.setWarningLevel(\n        DiagnosticGroups.DEPRECATED, CheckLevel.WARNING);\n  }\n"],"patch1-Chart-21-Nopol-plausible.patch":["0","    /**\r\n     * Tests this object for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object to test against (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (!(obj instanceof Range)) {\r\n            return false;\r\n        }\r\n        Range range = (Range) obj;\r\n        if (!(this.lower == range.lower)) {\r\n-            return false;\n+            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) {\n+                return false;\n+            }\n        }\r\n        if (!(this.upper == range.upper)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n"],"patch1-Closure-57-SimFix-plausible.patch":["0","  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n-          if (target != null) {\n+          if(target!=null&&target.getType()==Token.STRING){\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n"],"patch1-Chart-22-SimFix-plausible.patch":["0","    /**\r\n     * Removes an entire row from the table.\r\n     *\r\n     * @param rowKey  the row key (<code>null</code> not permitted).\r\n     * \r\n     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.\r\n     * \r\n     * @see #removeColumn(Comparable)\r\n     */\r\n    public void removeRow(Comparable rowKey) {\r\n        int index = getRowIndex(rowKey);\r\n+        if(index<0){\n+            throw new UnknownKeyException(\"The key (\"+rowKey.toString());\n+        }\n        removeRow(index);\r\n    }\r\n"],"patch1-Math-62-AVATAR-plausible.patch":["0","    /** {@inheritDoc} */\n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                 final double min, final double max,\n                                                 final double startValue)\n        throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        // Multi-start loop.\n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        // Return the point with the best objective function value.\n        return optima[0];\n    }\n"],"patch1-Math-62-TBar-plausible.patch":["0","    /** {@inheritDoc} */\n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                 final double min, final double max,\n                                                 final double startValue)\n        throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        // Multi-start loop.\n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        // Return the point with the best objective function value.\n        return optima[0];\n    }\n"],"patch1-Math-62-kPAR-plausible.patch":["0","    /** {@inheritDoc} */\n    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                 final double min, final double max,\n                                                 final double startValue)\n        throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        // Multi-start loop.\n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2));\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        // Return the point with the best objective function value.\n        return optima[0];\n    }\n"],"patch1-Math-63-SequenceR.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x==y;\n    }\n"],"patch1-Math-63-FixMiner-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n    }\n"],"patch1-Math-63-TBar-plausible.patch":["0","    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link #equals(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n+            if (!equals(x[i], y[i], i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n"],"patch1-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y;\n    }\n"],"patch7-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y;\n    }\n"],"patch1-Math-63-Cardumen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1)) || abs(y - x) <= SAFE_MIN;\n    }\n"],"patch6-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x > 0.0 ? 1.0 : -1.0)) || x == y;\n    }\n"],"patch1-Math-63-kPAR-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n    }\n"],"patch3-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == 0.0 || x == y;\n    }\n"],"patch5-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x >= 0.0 ? 1.0 : -1.0)) || x == y;\n    }\n"],"patch4-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI)) || x == y;\n    }\n"],"patch2-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y || x == y;\n    }\n"],"patch8-Math-63-CapGen-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI) && Double.isNaN(y)) || x == y;\n    }\n"],"patch1-Math-63-SimFix-plausible.patch":["0","    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;\n    }\n"],"patch1-Lang-57-FixMiner-plausible.patch":["0","    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n    }\n"],"patch1-Lang-57-kPAR-plausible.patch":["0","    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n    }\n"],"patch8-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(size + (size) + 5);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch4-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                ensureCapacity(((size) + 5));\n+str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch13-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n-            if (strLen >= width) {\n+            ensureCapacity(((size) + 4));\n+if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch2-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity((size) + 4);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch9-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(size + (size) + 4);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch3-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n-        if (width > 0) {\n+        ensureCapacity(((size) + 4));\n+if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch12-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n-            if (strLen >= width) {\n+            ensureCapacity(((size) + 5));\n+if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch5-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                ensureCapacity(((size) + 4));\n+str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch11-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(((size) + 4));\n+ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch6-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n-            String str = (obj == null ? getNullText() : obj.toString());\n+            ensureCapacity(((size) + 5));\n+String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch1-Lang-59-AVATAR-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch1-Lang-59-kPAR-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch1-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity((size) + 5);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch7-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n-        if (width > 0) {\n+        ensureCapacity(((size) + 5));\n+if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch10-Lang-59-CapGen-plausible.patch":["0","    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(((size) + 5));\n+ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n"],"patch1-Lang-58-TBar-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-58-Nopol-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                    if ((numeric.length()) != (short) 1) {\n+                        throw new NumberFormatException(str + \" is not a valid number.\");\n+                    }\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-58-AVATAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n-                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Lang-58-kPAR-plausible.patch":["0","    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n-                    if (dec == null\n-                        && exp == null\n+                    if (dec == null || exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n"],"patch1-Time-17-kPAR-plausible.patch":["0","    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }\n"],"patch1-Time-14-Nopol-plausible.patch":["0","    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        if ((org.joda.time.chrono.BasicMonthOfYearDateTimeField.MIN <= fieldIndex) || ((!(1 == valueToAdd)) && ((valueToAdd) != (-1)))) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n"],"patch1-Math-80-Jaid-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n+            if((step > 4 * (n - 1)) == false){\r\n+              \treturn true;\r\n+            \t}\r\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-kPAR-plausible.patch":["0","    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        goodStep(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n"],"patch3-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n+            for (int i = 0; i < 2 * (pingPong); i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch5-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[j - k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch2-Math-80-Jaid-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n+            if((4 * (n - 1) >= 0) == true){\r\n+            \treturn 1.5 * work[pingPong] < work[4 * (n - 1) + pingPong];\r\n+            \t}\r\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch9-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + 1] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-Kali-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n+                    if (true)\n+                        return true;\n+                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch4-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+                    work[i + k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-FixMiner-plausible.patch":["0","    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        goodStep(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n"],"patch2-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * pingPong - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch8-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j = (4 * (n - 1)) + (pingPong);\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-SimFix-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n+                for(int k=0;k<0;k+=step){\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-RSRepair-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n+            int mBlockIndex = 0;\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-Arja-plausible.patch":["0","    /**\n     * Perform one \"good\" dqd/dqds step.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLAZQ3.</p>\n     * @param start start index\n     * @param end end index\n     * @return new end (maybe deflated)\n     */\n    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        // step 1: accepting realEigenvalues\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                // the array has been completely deflated\n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                // one eigenvalue found, deflate array\n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                // two realEigenvalues found, deflate array\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                // no more realEigenvalues found, we need to iterate\n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        // step 2: flip array if needed\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin = 0.0;\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            // step 3: choose a shift\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            // step 4a: dqds\n            for (boolean loop = true; loop;) {\n\n                // perform one dqds step with the chosen shift\n                dqds(start, deflatedEnd);\n\n                // check result of the dqds step\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    // the shift was good\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   // convergence hidden by negative DN.\n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    // tau too big. Select new tau and try again.\n                    if (tType < -22) {\n                        // failed twice. Play it safe.\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        // late failure. Gives excellent shift.\n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        // early failure. Divide by 4.\n                        tau *= 0.25;\n-                        tType -= 12;\n+                        tType = -8;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n"],"patch1-Math-80-TBar-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-DynaMoth-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+            if (false) {\n+                for (int i = 0; i < j; i += 4) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n+                    j -= 4;\n                }\n-                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n+            for (int i = 0; i < pingPong; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch7-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * 2 * (pingPong) - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch10-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + 3] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-SequenceR.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j=(3-n)*1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch3-Math-80-Jaid-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n+            if((4 * (n - 1) == 0) == false){\r\n+            \treturn true;\r\n+            \t}\r\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-Nopol-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-AVATAR-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch6-Math-80-CapGen-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + k] = work[i + k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-GenProg-plausible.patch":["0","    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n-                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n"],"patch1-Math-80-jMutRepair-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n+        if (1.5 * this.work[this.pingPong] < this.work[4 * (n - 1) + this.pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Math-80-jKali-plausible.patch":["0","    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n            return true;\n        }\n        return false;\n    }\n"],"patch1-Time-11-DynaMoth-plausible.patch":["0","    /**\n     * Add a recurring daylight saving time rule.\n     *\n     * @param nameKey  the name key of new rule\n     * @param saveMillis  the milliseconds to add to standard offset\n     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates\n     * beginning of time\n     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE\n     *  indicates end of time\n     * @param mode  'u' - transitions are calculated against UTC, 'w' -\n     *  transitions are calculated against wall offset, 's' - transitions are\n     *  calculated against standard offset\n     * @param monthOfYear  the month from 1 (January) to 12 (December)\n     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n     *  For example, if -1, set to last day of month\n     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n     *  dayOfWeek when true, retreat when false.\n     * @param millisOfDay  additional precision for specifying time of day of transitions\n     */\n    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,\n                                                   int fromYear, int toYear,\n                                                   char mode,\n                                                   int monthOfYear,\n                                                   int dayOfMonth,\n                                                   int dayOfWeek,\n                                                   boolean advanceDayOfWeek,\n                                                   int millisOfDay)\n    {\n-        if (fromYear <= toYear) {\n-            OfYear ofYear = new OfYear\n+        if (nameKey.length() != 0) {\n+            if (fromYear <= toYear) {\n+                OfYear ofYear = new OfYear\n                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n-            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n-            Rule rule = new Rule(recurrence, fromYear, toYear);\n-            getLastRuleSet().addRule(rule);\n+                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n+                Rule rule = new Rule(recurrence, fromYear, toYear);\n+                getLastRuleSet().addRule(rule);\n+            }\n        }\n        return this;\n    }\n"],"patch1-Time-11-FixMiner-plausible.patch":["0","    /**\n     * Gets a flag indicating that verbose logging is required.\n     * @return true to log verbosely\n     */\n    public static boolean verbose() {\n-        return cVerbose.get();\n+        return cVerbose != null || cVerbose.get();\n    }\n"],"patch1-Math-81-SimFix-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if(b2>0.0&&b2>b2*b1/(1+b2*b2)){\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-FixMiner-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (work[np - 8] <= b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-RSRepair-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n-                final double gam = dN2;\n+                b2 = work[nn - 5] / work[nn - 7];\n+                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-Kali-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-ACS-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n+if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-GenProg-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n-\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-Nopol-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n-                        a2 = 0.0;\n+                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                            a2 = 0.0;\n+                        }\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-kPAR-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (work[np - 8] <= b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-AVATAR-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * start;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-jMutRepair-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (this.work[np - 8] != b2 || this.work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-DynaMoth-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-Arja-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n-                // case 5.\n-                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-TBar-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * this.tType;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-81-jGenProg-plausible.patch":["0","    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n+                \n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n"],"patch1-Math-82-TBar-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch2-Math-82-SketchFix-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio < minRatio&&ratio>=0) {\r\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-82-Arja-plausible.patch":["0","    /**\n     * Get the current solution.\n     * \n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n      Set<Integer> basicRows = new HashSet<Integer>();\n      for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value \n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0;\n          } else {\n              basicRows.add(basicRow);\n-              coefficients[i] =\n+              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n+                int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n+                subtractRow(0, row, 1.0);\n+            }\n+            coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n"],"patch1-Math-82-SimFix-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch1-Math-82-GenProg-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch1-Math-82-SketchFix-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, entry) >= 0) {\r\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-82-DynaMoth-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (false) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch3-Math-82-Jaid-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio < minRatio || (minRatio >= rhs / entry) == true) {\r\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch2-Math-82-Jaid-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n+                    if((rhs == minRatio) == false){\r\n+                    \tminRatio=rhs;\r\n+                    \t}\r\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-82-RSRepair-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch1-Math-82-kPAR-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch1-Math-82-Jaid-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n+                \tif((rhs > minRatio) == false){\r\n+                \t\tminRatio=rhs;\r\n+                \t\t}else{\r\n                    minRatio = ratio;\n+                \t\t}\r\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-82-AVATAR-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) {\n                minValue = tableau.getEntry(0, i);\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch3-Math-82-SequenceR.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Math-82-Nopol-plausible.patch":["0","    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON == minValue) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n"],"patch4-Math-82-Jaid-plausible.patch":["0","    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n+                \tif(!((i == 1) == true)){\r\n                    minRatio = ratio;\n+                \t}\r\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n"],"patch1-Chart-12-SimFix-plausible.patch":["0","    /**\r\n     * Creates a new plot.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     */\r\n    public MultiplePiePlot(CategoryDataset dataset) {\r\n        super();\r\n+        if(dataset!=null){\n+            dataset.addChangeListener(this);\n+        }\n        this.dataset = dataset;\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\r\n        this.aggregatedItemsKey = \"Other\";\r\n        this.aggregatedItemsPaint = Color.lightGray;\r\n        this.sectionPaints = new HashMap();\r\n    }\r\n"],"patch1-Chart-12-Kali-plausible.patch":["0","    /**\r\n     * Returns <code>true</code> if the specified object is registered with\r\n     * the dataset as a listener.  Most applications won't need to call this \r\n     * method, it exists mainly for use by unit testing code.\r\n     * \r\n     * @param listener  the listener.\r\n     * \r\n     * @return A boolean.\r\n     * \r\n     * @see #addChangeListener(DatasetChangeListener)\r\n     * @see #removeChangeListener(DatasetChangeListener)\r\n     */\r\n    public boolean hasListener(EventListener listener) {\r\n-        List list = Arrays.asList(this.listenerList.getListenerList());\n+        if (true)\n+            return true;\n+        List list = Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\r\n    }\r\n"],"patch1-Chart-12-RSRepair-plausible.patch":["0","    /**\r\n     * Creates a new plot.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     */\r\n    public MultiplePiePlot(CategoryDataset dataset) {\r\n        super();\r\n        this.dataset = dataset;\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\r\n-        this.aggregatedItemsKey = \"Other\";\n+        if (dataset != null) {\n+            dataset.addChangeListener(this);\n+        }\n+        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\r\n        this.sectionPaints = new HashMap();\r\n    }\r\n"],"patch1-Chart-12-GenProg-plausible.patch":["0","    /**\r\n     * Removes the first legend in the chart and sends a \r\n     * {@link ChartChangeEvent} to all registered listeners.\r\n     * \r\n     * @see #getLegend()\r\n     */\r\n    public void removeLegend() {\r\n-        removeSubtitle(getLegend());\n    }\r\n"],"patch1-Chart-12-TBar-plausible.patch":["0","    /**\r\n     * Returns <code>true</code> if the specified object is registered with\r\n     * the dataset as a listener.  Most applications won't need to call this \r\n     * method, it exists mainly for use by unit testing code.\r\n     * \r\n     * @param listener  the listener.\r\n     * \r\n     * @return A boolean.\r\n     * \r\n     * @see #addChangeListener(DatasetChangeListener)\r\n     * @see #removeChangeListener(DatasetChangeListener)\r\n     */\r\n    public boolean hasListener(EventListener listener) {\r\n        List list = Arrays.asList(this.listenerList.getListenerList());\r\n-        return list.contains(listener);\n+        return list != null || list.contains(listener);\n    }\r\n"],"patch1-Chart-13-RSRepair-plausible.patch":["0","    /**\r\n     * Arranges the container width a fixed width and no constraint on the\r\n     * height.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param width  the fixed width.\r\n     *\r\n     * @return The container size after arranging the contents.\r\n     */\r\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\r\n                               double width) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\r\n                LengthConstraintType.FIXED, 0.0, null,\r\n                LengthConstraintType.NONE);\r\n        if (this.topBlock != null) {\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Size2D size = this.bottomBlock.arrange(g2, c1);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\r\n                new Range(0.0, width), LengthConstraintType.RANGE,\r\n                0.0, null, LengthConstraintType.NONE);\r\n        if (this.leftBlock != null) {\r\n            Size2D size = this.leftBlock.arrange(g2, c2);\r\n            w[2] = size.width;\r\n            h[2] = size.height;\r\n        }\r\n        if (this.rightBlock != null) {\r\n            double maxW = Math.max(width - w[2], 0.0);\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(Math.min(w[2], maxW), maxW),\r\n                    LengthConstraintType.RANGE, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.rightBlock.arrange(g2, c3);\r\n-            w[3] = size.width;\n            h[3] = size.height;\r\n        }\r\n\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n\r\n        if (this.centerBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\r\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.centerBlock.arrange(g2, c4);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\r\n        return arrange(container, g2, new RectangleConstraint(width, height));\r\n    }\r\n"],"patch1-Chart-13-kPAR-plausible.patch":["0","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\n+        if ((this.leftBlock != null) && !(this.rightBlock != null)) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth()),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"patch1-Chart-13-FixMiner-plausible.patch":["0","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\n+        if ((this.leftBlock != null) && !(this.rightBlock != null)) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth()),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"patch1-Chart-13-GenProg-plausible.patch":["0","    /**\r\n     * Arranges the container width a fixed width and no constraint on the\r\n     * height.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param width  the fixed width.\r\n     *\r\n     * @return The container size after arranging the contents.\r\n     */\r\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\r\n                               double width) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\r\n                LengthConstraintType.FIXED, 0.0, null,\r\n                LengthConstraintType.NONE);\r\n        if (this.topBlock != null) {\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Size2D size = this.bottomBlock.arrange(g2, c1);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\r\n                new Range(0.0, width), LengthConstraintType.RANGE,\r\n                0.0, null, LengthConstraintType.NONE);\r\n        if (this.leftBlock != null) {\r\n            Size2D size = this.leftBlock.arrange(g2, c2);\r\n            w[2] = size.width;\r\n-            h[2] = size.height;\n+            this.topBlock = null;\n+            h[2] = size.height;\n        }\r\n        if (this.rightBlock != null) {\r\n            double maxW = Math.max(width - w[2], 0.0);\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(Math.min(w[2], maxW), maxW),\r\n                    LengthConstraintType.RANGE, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.rightBlock.arrange(g2, c3);\r\n            w[3] = size.width;\r\n            h[3] = size.height;\r\n        }\r\n\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n\r\n        if (this.centerBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\r\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.centerBlock.arrange(g2, c4);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\r\n        return arrange(container, g2, new RectangleConstraint(width, height));\r\n    }\r\n"],"patch1-Chart-13-Cardumen-plausible.patch":["0","    /**\r\n     * Arranges the items in the specified container, subject to the given\r\n     * constraint.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param constraint  the constraint.\r\n     *\r\n     * @return The block size.\r\n     */\r\n    public Size2D arrange(BlockContainer container,\r\n                          Graphics2D g2,\r\n                          RectangleConstraint constraint) {\r\n        RectangleConstraint contentConstraint\r\n                = container.toContentConstraint(constraint);\r\n        Size2D contentSize = null;\r\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\r\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\r\n        if (w == LengthConstraintType.NONE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeNN(container, g2);\r\n            }\r\n            else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n        }\r\n        else if (w == LengthConstraintType.FIXED) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\r\n            }\r\n            else if (h == LengthConstraintType.FIXED) {\r\n-                contentSize = arrangeFF(container, g2, constraint);\n+                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight());\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeFR(container, g2, constraint);\r\n            }\r\n        }\r\n        else if (w == LengthConstraintType.RANGE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\r\n                        constraint.getHeightRange(), g2);\r\n            }\r\n        }\r\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\r\n                container.calculateTotalHeight(contentSize.getHeight()));\r\n    }\r\n"],"patch1-Chart-13-Arja-plusible.patch":["0","    /**\r\n     * Arranges the container width a fixed width and no constraint on the\r\n     * height.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param width  the fixed width.\r\n     *\r\n     * @return The container size after arranging the contents.\r\n     */\r\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\r\n                               double width) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\r\n                LengthConstraintType.FIXED, 0.0, null,\r\n                LengthConstraintType.NONE);\r\n        if (this.topBlock != null) {\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Size2D size = this.bottomBlock.arrange(g2, c1);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\r\n                new Range(0.0, width), LengthConstraintType.RANGE,\r\n                0.0, null, LengthConstraintType.NONE);\r\n        if (this.leftBlock != null) {\r\n            Size2D size = this.leftBlock.arrange(g2, c2);\r\n            w[2] = size.width;\r\n            h[2] = size.height;\r\n        }\r\n        if (this.rightBlock != null) {\r\n            double maxW = Math.max(width - w[2], 0.0);\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(Math.min(w[2], maxW), maxW),\r\n                    LengthConstraintType.RANGE, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.rightBlock.arrange(g2, c3);\r\n            w[3] = size.width;\r\n            h[3] = size.height;\r\n        }\r\n\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n\r\n        if (this.centerBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\r\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\r\n                    LengthConstraintType.NONE);\r\n            Size2D size = this.centerBlock.arrange(g2, c4);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n-        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n+        this.rightBlock = null;\n+        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\r\n    }\r\n"],"patch1-Chart-13-TBar-plausible.patch":["0","    /**\r\n     * Creates a new range.\r\n     *\r\n     * @param lower  the lower bound (must be <= upper bound).\r\n     * @param upper  the upper bound (must be >= lower bound).\r\n     */\r\n    public Range(double lower, double upper) {\r\n        if (lower > upper) {\r\n            String msg = \"Range(double, double): require lower (\" + lower \r\n                + \") <= upper (\" + upper + \").\";\r\n-            throw new IllegalArgumentException(msg);\n+            \n        }\r\n        this.lower = lower;\r\n        this.upper = upper;\r\n    }\r\n"],"patch1-Chart-13-jKali-plausible.patch":["0","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\n+        if (false) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth()),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"patch1-Chart-13-DynaMoth-plausible.patch":["0","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (false) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"patch1-Chart-13-jGenProg-plausible.patch":["0","    /**\r\n     * Arranges the items in the specified container, subject to the given\r\n     * constraint.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param constraint  the constraint.\r\n     *\r\n     * @return The block size.\r\n     */\r\n    public Size2D arrange(BlockContainer container,\r\n                          Graphics2D g2,\r\n                          RectangleConstraint constraint) {\r\n        RectangleConstraint contentConstraint\r\n                = container.toContentConstraint(constraint);\r\n        Size2D contentSize = null;\r\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\r\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\r\n        if (w == LengthConstraintType.NONE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeNN(container, g2);\r\n            }\r\n            else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n        }\r\n        else if (w == LengthConstraintType.FIXED) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\r\n            }\r\n-           else if (h == LengthConstraintType.FIXED) {\n+           else{\n+                 this.rightBlock = null;\n+                 else if (h == LengthConstraintType.FIXED) {\n                contentSize = arrangeFF(container, g2, constraint);\r\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeFR(container, g2, constraint);\r\n            }\r\n+           }\n        }\r\n        else if (w == LengthConstraintType.RANGE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n            else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\r\n                        constraint.getHeightRange(), g2);\r\n            }\r\n        }\r\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\r\n                container.calculateTotalHeight(contentSize.getHeight()));\r\n    }\r\n"],"patch1-Chart-13-AVATAR-plausible.patch":["0","    /**\r\n     * Creates a new range.\r\n     *\r\n     * @param lower  the lower bound (must be <= upper bound).\r\n     * @param upper  the upper bound (must be >= lower bound).\r\n     */\r\n    public Range(double lower, double upper) {\r\n        if (lower > upper) {\r\n-            String msg = \"Range(double, double): require lower (\" + lower \n-                + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            \n        }\r\n        this.lower = lower;\r\n        this.upper = upper;\r\n    }\r\n"],"patch1-Chart-13-Nopol-plausible.patch":["0","    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n                               RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0,\r\n                    new Range(0.0, constraint.getHeight()),\r\n                    LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (null!=null) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n                    h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n                    w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n                    h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n                    w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n                    h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n"],"patch1-Chart-14-TBar-plausible.patch":["0","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"patch1-Chart-14-Arja-plusible.patch":["0","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n-            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n-                    index));\n+            return this.rangeCrosshairVisible;\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"patch1-Chart-14-FixMiner-plausible.patch":["0","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"patch1-Chart-14-kPAR-plausible.patch":["0","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"patch1-Chart-14-AVATAR-plausible.patch":["0","    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested, \r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually \r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n    \t\tboolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n        else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                    index));\r\n        }\r\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n"],"patch1-Chart-15-DynaMoth-plausible.patch":["0","    /**\r\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\r\n     * printer).\r\n     * <P>\r\n     * This method is the focus of the entire JFreeChart library.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param chartArea  the area within which the chart should be drawn.\r\n     * @param anchor  the anchor point (in Java2D space) for the chart \r\n     *                (<code>null</code> permitted).\r\n     * @param info  records info about the drawing (null means collect no info).\r\n     */\r\n    public void draw(Graphics2D g2, \r\n                     Rectangle2D chartArea, Point2D anchor, \r\n                     ChartRenderingInfo info) {\r\n\r\n        notifyListeners(new ChartProgressEvent(this, this, \r\n                ChartProgressEvent.DRAWING_STARTED, 0));\r\n\r\n        // record the chart area, if info is requested...\r\n        if (info != null) {\r\n            info.clear();\r\n            info.setChartArea(chartArea);\r\n        }\r\n\r\n        // ensure no drawing occurs outside chart area...\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(chartArea);\r\n\r\n        g2.addRenderingHints(this.renderingHints);\r\n\r\n        // draw the chart background...\r\n        if (this.backgroundPaint != null) {\r\n            g2.setPaint(this.backgroundPaint);\r\n            g2.fill(chartArea);\r\n        }\r\n\r\n        if (this.backgroundImage != null) {\r\n            Composite originalComposite = g2.getComposite();\r\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                    this.backgroundImageAlpha));\r\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \r\n                    this.backgroundImage.getWidth(null), \r\n                    this.backgroundImage.getHeight(null));\r\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\r\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \r\n                    (int) dest.getY(), (int) dest.getWidth(), \r\n                    (int) dest.getHeight(), null);\r\n            g2.setComposite(originalComposite);\r\n        }\r\n\r\n        if (isBorderVisible()) {\r\n            Paint paint = getBorderPaint();\r\n            Stroke stroke = getBorderStroke();\r\n            if (paint != null && stroke != null) {\r\n                Rectangle2D borderArea = new Rectangle2D.Double(\r\n                        chartArea.getX(), chartArea.getY(), \r\n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \r\n                        - 1.0);\r\n                g2.setPaint(paint);\r\n                g2.setStroke(stroke);\r\n                g2.draw(borderArea);\r\n            }\r\n        }\r\n\r\n        // draw the title and subtitles...\r\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\r\n        nonTitleArea.setRect(chartArea);\r\n        this.padding.trim(nonTitleArea);\r\n        \r\n        EntityCollection entities = null;\r\n        if (info != null) {\r\n            entities = info.getEntityCollection();   \r\n        }\r\n        if (this.title != null) {\r\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \r\n                    (entities != null));\r\n            if (e != null) {\r\n                entities.addAll(e);   \r\n            }\r\n        }\r\n\r\n        Iterator iterator = this.subtitles.iterator();\r\n        while (iterator.hasNext()) {\r\n            Title currentTitle = (Title) iterator.next();\r\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \r\n                    (entities != null));\r\n            if (e != null) {\r\n                entities.addAll(e);   \r\n            }\r\n        }\r\n\r\n        Rectangle2D plotArea = nonTitleArea;\r\n \r\n        // draw the plot (axes and data visualisation)\r\n        PlotRenderingInfo plotInfo = null;\r\n        if (info != null) {\r\n            plotInfo = info.getPlotInfo();\r\n        }\r\n-        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        if (false) {\n+            this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        }\n\r\n        g2.setClip(savedClip);\r\n\r\n        notifyListeners(new ChartProgressEvent(this, this, \r\n                ChartProgressEvent.DRAWING_FINISHED, 100));\r\n    }\r\n"],"patch1-Chart-15-TBar-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Chart-15-Arja-plusible.patch":["0","    /**\r\n     * Creates a 3D pie chart using the specified dataset.  The chart object \r\n     * returned by this method uses a {@link PiePlot3D} instance as the\r\n     * plot.\r\n     *\r\n     * @param title  the chart title (<code>null</code> permitted).\r\n     * @param dataset  the dataset for the chart (<code>null</code> permitted).\r\n     * @param legend  a flag specifying whether or not a legend is required.\r\n     * @param tooltips  configure chart to generate tool tips?\r\n     * @param urls  configure chart to generate URLs?\r\n     *\r\n     * @return A pie chart.\r\n     */\r\n    public static JFreeChart createPieChart3D(String title,\r\n                                              PieDataset dataset,\r\n                                              boolean legend,\r\n                                              boolean tooltips,\r\n                                              boolean urls) {\r\n\r\n-        PiePlot3D plot = new PiePlot3D(dataset);\n+        PiePlot plot = new PiePlot(dataset);\n        plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0));\r\n        if (tooltips) {\r\n            plot.setToolTipGenerator(new StandardPieToolTipGenerator());\r\n        }\r\n        if (urls) {\r\n            plot.setURLGenerator(new StandardPieURLGenerator());\r\n        }\r\n        return new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT, plot, \r\n                legend);\r\n\r\n    }\r\n"],"patch1-Chart-15-AVATAR-plausible.patch":["0","public static void dummyMethod(){\n        String info = \"deleteAllMethod\";\n}"],"patch1-Chart-15-Kali-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).  This method is called by the \r\n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \r\n     * to call it yourself.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the area within which the plot should be drawn.\r\n     * @param anchor  the anchor point.\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param info  collects info about the drawing \r\n     *              (<code>null</code> permitted).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo info) {\r\n\r\n        // adjust for insets...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(plotArea);\r\n\r\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\r\n        if (info != null) {\r\n            info.setPlotArea(plotArea);\r\n            info.setDataArea(plotArea);\r\n        }\r\n\r\n        drawBackground(g2, plotArea);\r\n\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(plotArea);\r\n\r\n        // adjust the plot area by the interior spacing value\r\n        double gapPercent = getInteriorGap();\r\n        double labelPercent = 0.0;\r\n        if (getLabelGenerator() != null) {\r\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \r\n        }\r\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \r\n                + labelPercent) * 2.0;\r\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\r\n\r\n        if (DEBUG_DRAW_INTERIOR) {\r\n            double hGap = plotArea.getWidth() * getInteriorGap();\r\n            double vGap = plotArea.getHeight() * getInteriorGap();\r\n            double igx1 = plotArea.getX() + hGap;\r\n            double igx2 = plotArea.getMaxX() - hGap;\r\n            double igy1 = plotArea.getY() + vGap;\r\n            double igy2 = plotArea.getMaxY() - vGap;\r\n            g2.setPaint(Color.lightGray);\r\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \r\n                    igy2 - igy1));\r\n        }\r\n\r\n        double linkX = plotArea.getX() + gapHorizontal / 2;\r\n        double linkY = plotArea.getY() + gapVertical / 2;\r\n        double linkW = plotArea.getWidth() - gapHorizontal;\r\n        double linkH = plotArea.getHeight() - gapVertical;\r\n        \r\n        // make the link area a square if the pie chart is to be circular...\r\n        if (isCircular()) { // is circular?\r\n            double min = Math.min(linkW, linkH) / 2;\r\n            linkX = (linkX + linkX + linkW) / 2 - min;\r\n            linkY = (linkY + linkY + linkH) / 2 - min;\r\n            linkW = 2 * min;\r\n            linkH = 2 * min;\r\n        }\r\n        \r\n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (true)\n+            return;\n+        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\r\n        // the link area defines the dog leg points for the linking lines to \r\n        // the labels\r\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH * (1 - this.depthFactor));\r\n        state.setLinkArea(linkAreaXX);\r\n\r\n        if (DEBUG_DRAW_LINK_AREA) {\r\n            g2.setPaint(Color.blue);\r\n            g2.draw(linkAreaXX);\r\n            g2.setPaint(Color.yellow);\r\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \r\n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\r\n        }\r\n        \r\n        // the explode area defines the max circle/ellipse for the exploded pie \r\n        // sections.\r\n        // it is defined by shrinking the linkArea by the linkMargin factor.\r\n        double hh = linkW * getLabelLinkMargin();\r\n        double vv = linkH * getLabelLinkMargin();\r\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \r\n                linkY + vv / 2.0, linkW - hh, linkH - vv);\r\n       \r\n        state.setExplodedPieArea(explodeArea);\r\n        \r\n        // the pie area defines the circle/ellipse for regular pie sections.\r\n        // it is defined by shrinking the explodeArea by the explodeMargin \r\n        // factor. \r\n        double maximumExplodePercent = getMaximumExplodePercent();\r\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\r\n        \r\n        double h1 = explodeArea.getWidth() * percent;\r\n        double v1 = explodeArea.getHeight() * percent;\r\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \r\n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\r\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\r\n\r\n        // the link area defines the dog-leg point for the linking lines to \r\n        // the labels\r\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\r\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH - depth);\r\n        state.setLinkArea(linkArea);   \r\n\r\n        state.setPieArea(pieArea);\r\n        state.setPieCenterX(pieArea.getCenterX());\r\n        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\r\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\r\n        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\r\n\r\n        // get the data source - return if null;\r\n        PieDataset dataset = getDataset();\r\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\r\n            drawNoDataMessage(g2, plotArea);\r\n            g2.setClip(savedClip);\r\n            drawOutline(g2, plotArea);\r\n            return;\r\n        }\r\n\r\n        // if too any elements\r\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\r\n            String text = \"Too many elements\";\r\n            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\r\n            g2.setFont(sfont);\r\n            FontMetrics fm = g2.getFontMetrics(sfont);\r\n            int stringWidth = fm.stringWidth(text);\r\n\r\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \r\n                    - stringWidth) / 2), (int) (plotArea.getY() \r\n                    + (plotArea.getHeight() / 2)));\r\n            return;\r\n        }\r\n        // if we are drawing a perfect circle, we need to readjust the top left\r\n        // coordinates of the drawing area for the arcs to arrive at this\r\n        // effect.\r\n        if (isCircular()) {\r\n            double min = Math.min(plotArea.getWidth(), \r\n                    plotArea.getHeight()) / 2;\r\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \r\n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\r\n        }\r\n        // get a list of keys...\r\n        List sectionKeys = dataset.getKeys();\r\n\r\n        if (sectionKeys.size() == 0) {\r\n            return;\r\n        }\r\n\r\n        // establish the coordinates of the top left corner of the drawing area\r\n        double arcX = pieArea.getX();\r\n        double arcY = pieArea.getY();\r\n\r\n        //g2.clip(clipArea);\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                getForegroundAlpha()));\r\n\r\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\r\n        double runningTotal = 0;\r\n        if (depth < 0) {\r\n            return;  // if depth is negative don't draw anything\r\n        }\r\n\r\n        ArrayList arcList = new ArrayList();\r\n        Arc2D.Double arc;\r\n        Paint paint;\r\n        Paint outlinePaint;\r\n        Stroke outlineStroke;\r\n\r\n        Iterator iterator = sectionKeys.iterator();\r\n        while (iterator.hasNext()) {\r\n\r\n            Comparable currentKey = (Comparable) iterator.next();\r\n            Number dataValue = dataset.getValue(currentKey);\r\n            if (dataValue == null) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double value = dataValue.doubleValue();\r\n            if (value <= 0) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double startAngle = getStartAngle();\r\n            double direction = getDirection().getFactor();\r\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \r\n                    / totalValue;\r\n            double angle2 = startAngle + (direction * (runningTotal + value) \r\n                    * 360) / totalValue;\r\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\r\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \r\n                        pieArea.getWidth(), pieArea.getHeight() - depth,\r\n                        angle1, angle2 - angle1, Arc2D.PIE));\r\n            }\r\n            else {\r\n                arcList.add(null);\r\n            }\r\n            runningTotal += value;\r\n        }\r\n\r\n        Shape oldClip = g2.getClip();\r\n\r\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \r\n                pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \r\n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \r\n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \r\n                - top.getCenterY());\r\n\r\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \r\n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\r\n\r\n        Area a = new Area(top);\r\n        a.add(new Area(lower));\r\n        Area b = new Area(bottom);\r\n        b.add(new Area(upper));\r\n        Area pie = new Area(a);\r\n        pie.intersect(b);\r\n\r\n        Area front = new Area(pie);\r\n        front.subtract(new Area(top));\r\n\r\n        Area back = new Area(pie);\r\n        back.subtract(new Area(bottom));\r\n\r\n        // draw the bottom circle\r\n        int[] xs;\r\n        int[] ys;\r\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \r\n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\r\n\r\n        int categoryCount = arcList.size();\r\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \r\n                 categoryIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            Comparable key = getSectionKey(categoryIndex);\r\n            paint = lookupSectionPaint(key, true);\r\n            outlinePaint = lookupSectionOutlinePaint(key);\r\n            outlineStroke = lookupSectionOutlineStroke(key);\r\n            g2.setPaint(paint);\r\n            g2.fill(arc);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(arc);\r\n            g2.setPaint(paint);\r\n\r\n            Point2D p1 = arc.getStartPoint();\r\n\r\n            // draw the height\r\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\r\n                    (int) p1.getX(), (int) p1.getX()};\r\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \r\n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\r\n            Polygon polygon = new Polygon(xs, ys, 4);\r\n            g2.setPaint(java.awt.Color.lightGray);\r\n            g2.fill(polygon);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(polygon);\r\n            g2.setPaint(paint);\r\n\r\n        }\r\n\r\n        g2.setPaint(Color.gray);\r\n        g2.fill(back);\r\n        g2.fill(front);\r\n\r\n        // cycle through once drawing only the sides at the back...\r\n        int cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key, true);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, false, true);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        // cycle through again drawing only the sides at the front...\r\n        cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, true, false);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        g2.setClip(oldClip);\r\n\r\n        // draw the sections at the top of the pie (and set up tooltips)...\r\n        Arc2D upperArc;\r\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \r\n                 sectionIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\r\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \r\n                    arc.getAngleExtent(), Arc2D.PIE);\r\n            \r\n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\r\n            paint = lookupSectionPaint(currentKey, true);\r\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\r\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\r\n            g2.setPaint(paint);\r\n            g2.fill(upperArc);\r\n            g2.setStroke(outlineStroke);\r\n            g2.setPaint(outlinePaint);\r\n            g2.draw(upperArc);\r\n\r\n           // add a tooltip for the section...\r\n            if (info != null) {\r\n                EntityCollection entities \r\n                        = info.getOwner().getEntityCollection();\r\n                if (entities != null) {\r\n                    String tip = null;\r\n                    PieToolTipGenerator tipster = getToolTipGenerator();\r\n                    if (tipster != null) {\r\n                        // @mgs: using the method's return value was missing \r\n                        tip = tipster.generateToolTip(dataset, currentKey);\r\n                    }\r\n                    String url = null;\r\n                    if (getURLGenerator() != null) {\r\n                        url = getURLGenerator().generateURL(dataset, currentKey,\r\n                                getPieIndex());\r\n                    }\r\n                    PieSectionEntity entity = new PieSectionEntity(\r\n                            upperArc, dataset, getPieIndex(), sectionIndex, \r\n                            currentKey, tip, url);\r\n                    entities.add(entity);\r\n                }\r\n            }\r\n            List keys = dataset.getKeys();\r\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\r\n                    originalPlotArea.getX(), originalPlotArea.getY(), \r\n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \r\n                    - depth);\r\n            if (getSimpleLabels()) {\r\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \r\n                        linkArea, state);\r\n            }\r\n            else {\r\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \r\n                        state);\r\n            }\r\n        }\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n        drawOutline(g2, originalPlotArea);\r\n\r\n    }\r\n"],"patch1-Chart-15-FixMiner-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).  This method is called by the \r\n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \r\n     * to call it yourself.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the area within which the plot should be drawn.\r\n     * @param anchor  the anchor point.\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param info  collects info about the drawing \r\n     *              (<code>null</code> permitted).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo info) {\r\n\r\n        // adjust for insets...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(plotArea);\r\n\r\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\r\n        if (info != null) {\r\n            info.setPlotArea(plotArea);\r\n            info.setDataArea(plotArea);\r\n        }\r\n\r\n        drawBackground(g2, plotArea);\r\n\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(plotArea);\r\n\r\n        // adjust the plot area by the interior spacing value\r\n        double gapPercent = getInteriorGap();\r\n        double labelPercent = 0.0;\r\n        if (getLabelGenerator() != null) {\r\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \r\n        }\r\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \r\n                + labelPercent) * 2.0;\r\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\r\n\r\n        if (DEBUG_DRAW_INTERIOR) {\r\n            double hGap = plotArea.getWidth() * getInteriorGap();\r\n            double vGap = plotArea.getHeight() * getInteriorGap();\r\n            double igx1 = plotArea.getX() + hGap;\r\n            double igx2 = plotArea.getMaxX() - hGap;\r\n            double igy1 = plotArea.getY() + vGap;\r\n            double igy2 = plotArea.getMaxY() - vGap;\r\n            g2.setPaint(Color.lightGray);\r\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \r\n                    igy2 - igy1));\r\n        }\r\n\r\n        double linkX = plotArea.getX() + gapHorizontal / 2;\r\n        double linkY = plotArea.getY() + gapVertical / 2;\r\n        double linkW = plotArea.getWidth() - gapHorizontal;\r\n        double linkH = plotArea.getHeight() - gapVertical;\r\n        \r\n        // make the link area a square if the pie chart is to be circular...\r\n        if (isCircular()) { // is circular?\r\n            double min = Math.min(linkW, linkH) / 2;\r\n            linkX = (linkX + linkX + linkW) / 2 - min;\r\n            linkY = (linkY + linkY + linkH) / 2 - min;\r\n            linkW = 2 * min;\r\n            linkH = 2 * min;\r\n        }\r\n        \r\n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (info == null) {\n+    return;\n+}\n+PiePlotState state = initialise(g2, plotArea, this, null, info);\n\r\n        // the link area defines the dog leg points for the linking lines to \r\n        // the labels\r\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH * (1 - this.depthFactor));\r\n        state.setLinkArea(linkAreaXX);\r\n\r\n        if (DEBUG_DRAW_LINK_AREA) {\r\n            g2.setPaint(Color.blue);\r\n            g2.draw(linkAreaXX);\r\n            g2.setPaint(Color.yellow);\r\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \r\n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\r\n        }\r\n        \r\n        // the explode area defines the max circle/ellipse for the exploded pie \r\n        // sections.\r\n        // it is defined by shrinking the linkArea by the linkMargin factor.\r\n        double hh = linkW * getLabelLinkMargin();\r\n        double vv = linkH * getLabelLinkMargin();\r\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \r\n                linkY + vv / 2.0, linkW - hh, linkH - vv);\r\n       \r\n        state.setExplodedPieArea(explodeArea);\r\n        \r\n        // the pie area defines the circle/ellipse for regular pie sections.\r\n        // it is defined by shrinking the explodeArea by the explodeMargin \r\n        // factor. \r\n        double maximumExplodePercent = getMaximumExplodePercent();\r\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\r\n        \r\n        double h1 = explodeArea.getWidth() * percent;\r\n        double v1 = explodeArea.getHeight() * percent;\r\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \r\n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\r\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\r\n\r\n        // the link area defines the dog-leg point for the linking lines to \r\n        // the labels\r\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\r\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH - depth);\r\n        state.setLinkArea(linkArea);   \r\n\r\n        state.setPieArea(pieArea);\r\n        state.setPieCenterX(pieArea.getCenterX());\r\n        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\r\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\r\n        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\r\n\r\n        // get the data source - return if null;\r\n        PieDataset dataset = getDataset();\r\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\r\n            drawNoDataMessage(g2, plotArea);\r\n            g2.setClip(savedClip);\r\n            drawOutline(g2, plotArea);\r\n            return;\r\n        }\r\n\r\n        // if too any elements\r\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\r\n            String text = \"Too many elements\";\r\n            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\r\n            g2.setFont(sfont);\r\n            FontMetrics fm = g2.getFontMetrics(sfont);\r\n            int stringWidth = fm.stringWidth(text);\r\n\r\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \r\n                    - stringWidth) / 2), (int) (plotArea.getY() \r\n                    + (plotArea.getHeight() / 2)));\r\n            return;\r\n        }\r\n        // if we are drawing a perfect circle, we need to readjust the top left\r\n        // coordinates of the drawing area for the arcs to arrive at this\r\n        // effect.\r\n        if (isCircular()) {\r\n            double min = Math.min(plotArea.getWidth(), \r\n                    plotArea.getHeight()) / 2;\r\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \r\n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\r\n        }\r\n        // get a list of keys...\r\n        List sectionKeys = dataset.getKeys();\r\n\r\n        if (sectionKeys.size() == 0) {\r\n            return;\r\n        }\r\n\r\n        // establish the coordinates of the top left corner of the drawing area\r\n        double arcX = pieArea.getX();\r\n        double arcY = pieArea.getY();\r\n\r\n        //g2.clip(clipArea);\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                getForegroundAlpha()));\r\n\r\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\r\n        double runningTotal = 0;\r\n        if (depth < 0) {\r\n            return;  // if depth is negative don't draw anything\r\n        }\r\n\r\n        ArrayList arcList = new ArrayList();\r\n        Arc2D.Double arc;\r\n        Paint paint;\r\n        Paint outlinePaint;\r\n        Stroke outlineStroke;\r\n\r\n        Iterator iterator = sectionKeys.iterator();\r\n        while (iterator.hasNext()) {\r\n\r\n            Comparable currentKey = (Comparable) iterator.next();\r\n            Number dataValue = dataset.getValue(currentKey);\r\n            if (dataValue == null) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double value = dataValue.doubleValue();\r\n            if (value <= 0) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double startAngle = getStartAngle();\r\n            double direction = getDirection().getFactor();\r\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \r\n                    / totalValue;\r\n            double angle2 = startAngle + (direction * (runningTotal + value) \r\n                    * 360) / totalValue;\r\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\r\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \r\n                        pieArea.getWidth(), pieArea.getHeight() - depth,\r\n                        angle1, angle2 - angle1, Arc2D.PIE));\r\n            }\r\n            else {\r\n                arcList.add(null);\r\n            }\r\n            runningTotal += value;\r\n        }\r\n\r\n        Shape oldClip = g2.getClip();\r\n\r\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \r\n                pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \r\n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \r\n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \r\n                - top.getCenterY());\r\n\r\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \r\n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\r\n\r\n        Area a = new Area(top);\r\n        a.add(new Area(lower));\r\n        Area b = new Area(bottom);\r\n        b.add(new Area(upper));\r\n        Area pie = new Area(a);\r\n        pie.intersect(b);\r\n\r\n        Area front = new Area(pie);\r\n        front.subtract(new Area(top));\r\n\r\n        Area back = new Area(pie);\r\n        back.subtract(new Area(bottom));\r\n\r\n        // draw the bottom circle\r\n        int[] xs;\r\n        int[] ys;\r\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \r\n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\r\n\r\n        int categoryCount = arcList.size();\r\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \r\n                 categoryIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            Comparable key = getSectionKey(categoryIndex);\r\n            paint = lookupSectionPaint(key, true);\r\n            outlinePaint = lookupSectionOutlinePaint(key);\r\n            outlineStroke = lookupSectionOutlineStroke(key);\r\n            g2.setPaint(paint);\r\n            g2.fill(arc);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(arc);\r\n            g2.setPaint(paint);\r\n\r\n            Point2D p1 = arc.getStartPoint();\r\n\r\n            // draw the height\r\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\r\n                    (int) p1.getX(), (int) p1.getX()};\r\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \r\n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\r\n            Polygon polygon = new Polygon(xs, ys, 4);\r\n            g2.setPaint(java.awt.Color.lightGray);\r\n            g2.fill(polygon);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(polygon);\r\n            g2.setPaint(paint);\r\n\r\n        }\r\n\r\n        g2.setPaint(Color.gray);\r\n        g2.fill(back);\r\n        g2.fill(front);\r\n\r\n        // cycle through once drawing only the sides at the back...\r\n        int cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key, true);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, false, true);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        // cycle through again drawing only the sides at the front...\r\n        cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, true, false);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        g2.setClip(oldClip);\r\n\r\n        // draw the sections at the top of the pie (and set up tooltips)...\r\n        Arc2D upperArc;\r\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \r\n                 sectionIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\r\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \r\n                    arc.getAngleExtent(), Arc2D.PIE);\r\n            \r\n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\r\n            paint = lookupSectionPaint(currentKey, true);\r\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\r\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\r\n            g2.setPaint(paint);\r\n            g2.fill(upperArc);\r\n            g2.setStroke(outlineStroke);\r\n            g2.setPaint(outlinePaint);\r\n            g2.draw(upperArc);\r\n\r\n           // add a tooltip for the section...\r\n            if (info != null) {\r\n                EntityCollection entities \r\n                        = info.getOwner().getEntityCollection();\r\n                if (entities != null) {\r\n                    String tip = null;\r\n                    PieToolTipGenerator tipster = getToolTipGenerator();\r\n                    if (tipster != null) {\r\n                        // @mgs: using the method's return value was missing \r\n                        tip = tipster.generateToolTip(dataset, currentKey);\r\n                    }\r\n                    String url = null;\r\n                    if (getURLGenerator() != null) {\r\n                        url = getURLGenerator().generateURL(dataset, currentKey,\r\n                                getPieIndex());\r\n                    }\r\n                    PieSectionEntity entity = new PieSectionEntity(\r\n                            upperArc, dataset, getPieIndex(), sectionIndex, \r\n                            currentKey, tip, url);\r\n                    entities.add(entity);\r\n                }\r\n            }\r\n            List keys = dataset.getKeys();\r\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\r\n                    originalPlotArea.getX(), originalPlotArea.getY(), \r\n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \r\n                    - depth);\r\n            if (getSimpleLabels()) {\r\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \r\n                        linkArea, state);\r\n            }\r\n            else {\r\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \r\n                        state);\r\n            }\r\n        }\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n        drawOutline(g2, originalPlotArea);\r\n\r\n    }\r\n"],"patch1-Chart-15-kPAR-plausible.patch":["0","    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \r\n     * printer).  This method is called by the \r\n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \r\n     * to call it yourself.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the area within which the plot should be drawn.\r\n     * @param anchor  the anchor point.\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param info  collects info about the drawing \r\n     *              (<code>null</code> permitted).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\r\n                     PlotState parentState,\r\n                     PlotRenderingInfo info) {\r\n\r\n        // adjust for insets...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(plotArea);\r\n\r\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\r\n        if (info != null) {\r\n            info.setPlotArea(plotArea);\r\n            info.setDataArea(plotArea);\r\n        }\r\n\r\n        drawBackground(g2, plotArea);\r\n\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(plotArea);\r\n\r\n        // adjust the plot area by the interior spacing value\r\n        double gapPercent = getInteriorGap();\r\n        double labelPercent = 0.0;\r\n        if (getLabelGenerator() != null) {\r\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \r\n        }\r\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \r\n                + labelPercent) * 2.0;\r\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\r\n\r\n        if (DEBUG_DRAW_INTERIOR) {\r\n            double hGap = plotArea.getWidth() * getInteriorGap();\r\n            double vGap = plotArea.getHeight() * getInteriorGap();\r\n            double igx1 = plotArea.getX() + hGap;\r\n            double igx2 = plotArea.getMaxX() - hGap;\r\n            double igy1 = plotArea.getY() + vGap;\r\n            double igy2 = plotArea.getMaxY() - vGap;\r\n            g2.setPaint(Color.lightGray);\r\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \r\n                    igy2 - igy1));\r\n        }\r\n\r\n        double linkX = plotArea.getX() + gapHorizontal / 2;\r\n        double linkY = plotArea.getY() + gapVertical / 2;\r\n        double linkW = plotArea.getWidth() - gapHorizontal;\r\n        double linkH = plotArea.getHeight() - gapVertical;\r\n        \r\n        // make the link area a square if the pie chart is to be circular...\r\n        if (isCircular()) { // is circular?\r\n            double min = Math.min(linkW, linkH) / 2;\r\n            linkX = (linkX + linkX + linkW) / 2 - min;\r\n            linkY = (linkY + linkY + linkH) / 2 - min;\r\n            linkW = 2 * min;\r\n            linkH = 2 * min;\r\n        }\r\n        \r\n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (info == null) {\n+    return;\n+}\n+PiePlotState state = initialise(g2, plotArea, this, null, info);\n\r\n        // the link area defines the dog leg points for the linking lines to \r\n        // the labels\r\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH * (1 - this.depthFactor));\r\n        state.setLinkArea(linkAreaXX);\r\n\r\n        if (DEBUG_DRAW_LINK_AREA) {\r\n            g2.setPaint(Color.blue);\r\n            g2.draw(linkAreaXX);\r\n            g2.setPaint(Color.yellow);\r\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \r\n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\r\n        }\r\n        \r\n        // the explode area defines the max circle/ellipse for the exploded pie \r\n        // sections.\r\n        // it is defined by shrinking the linkArea by the linkMargin factor.\r\n        double hh = linkW * getLabelLinkMargin();\r\n        double vv = linkH * getLabelLinkMargin();\r\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \r\n                linkY + vv / 2.0, linkW - hh, linkH - vv);\r\n       \r\n        state.setExplodedPieArea(explodeArea);\r\n        \r\n        // the pie area defines the circle/ellipse for regular pie sections.\r\n        // it is defined by shrinking the explodeArea by the explodeMargin \r\n        // factor. \r\n        double maximumExplodePercent = getMaximumExplodePercent();\r\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\r\n        \r\n        double h1 = explodeArea.getWidth() * percent;\r\n        double v1 = explodeArea.getHeight() * percent;\r\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \r\n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\r\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\r\n\r\n        // the link area defines the dog-leg point for the linking lines to \r\n        // the labels\r\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\r\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \r\n                linkH - depth);\r\n        state.setLinkArea(linkArea);   \r\n\r\n        state.setPieArea(pieArea);\r\n        state.setPieCenterX(pieArea.getCenterX());\r\n        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\r\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\r\n        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\r\n\r\n        // get the data source - return if null;\r\n        PieDataset dataset = getDataset();\r\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\r\n            drawNoDataMessage(g2, plotArea);\r\n            g2.setClip(savedClip);\r\n            drawOutline(g2, plotArea);\r\n            return;\r\n        }\r\n\r\n        // if too any elements\r\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\r\n            String text = \"Too many elements\";\r\n            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\r\n            g2.setFont(sfont);\r\n            FontMetrics fm = g2.getFontMetrics(sfont);\r\n            int stringWidth = fm.stringWidth(text);\r\n\r\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \r\n                    - stringWidth) / 2), (int) (plotArea.getY() \r\n                    + (plotArea.getHeight() / 2)));\r\n            return;\r\n        }\r\n        // if we are drawing a perfect circle, we need to readjust the top left\r\n        // coordinates of the drawing area for the arcs to arrive at this\r\n        // effect.\r\n        if (isCircular()) {\r\n            double min = Math.min(plotArea.getWidth(), \r\n                    plotArea.getHeight()) / 2;\r\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \r\n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\r\n        }\r\n        // get a list of keys...\r\n        List sectionKeys = dataset.getKeys();\r\n\r\n        if (sectionKeys.size() == 0) {\r\n            return;\r\n        }\r\n\r\n        // establish the coordinates of the top left corner of the drawing area\r\n        double arcX = pieArea.getX();\r\n        double arcY = pieArea.getY();\r\n\r\n        //g2.clip(clipArea);\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \r\n                getForegroundAlpha()));\r\n\r\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\r\n        double runningTotal = 0;\r\n        if (depth < 0) {\r\n            return;  // if depth is negative don't draw anything\r\n        }\r\n\r\n        ArrayList arcList = new ArrayList();\r\n        Arc2D.Double arc;\r\n        Paint paint;\r\n        Paint outlinePaint;\r\n        Stroke outlineStroke;\r\n\r\n        Iterator iterator = sectionKeys.iterator();\r\n        while (iterator.hasNext()) {\r\n\r\n            Comparable currentKey = (Comparable) iterator.next();\r\n            Number dataValue = dataset.getValue(currentKey);\r\n            if (dataValue == null) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double value = dataValue.doubleValue();\r\n            if (value <= 0) {\r\n                arcList.add(null);\r\n                continue;\r\n            }\r\n            double startAngle = getStartAngle();\r\n            double direction = getDirection().getFactor();\r\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \r\n                    / totalValue;\r\n            double angle2 = startAngle + (direction * (runningTotal + value) \r\n                    * 360) / totalValue;\r\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\r\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \r\n                        pieArea.getWidth(), pieArea.getHeight() - depth,\r\n                        angle1, angle2 - angle1, Arc2D.PIE));\r\n            }\r\n            else {\r\n                arcList.add(null);\r\n            }\r\n            runningTotal += value;\r\n        }\r\n\r\n        Shape oldClip = g2.getClip();\r\n\r\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \r\n                pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \r\n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\r\n\r\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \r\n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \r\n                - top.getCenterY());\r\n\r\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \r\n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\r\n\r\n        Area a = new Area(top);\r\n        a.add(new Area(lower));\r\n        Area b = new Area(bottom);\r\n        b.add(new Area(upper));\r\n        Area pie = new Area(a);\r\n        pie.intersect(b);\r\n\r\n        Area front = new Area(pie);\r\n        front.subtract(new Area(top));\r\n\r\n        Area back = new Area(pie);\r\n        back.subtract(new Area(bottom));\r\n\r\n        // draw the bottom circle\r\n        int[] xs;\r\n        int[] ys;\r\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \r\n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\r\n\r\n        int categoryCount = arcList.size();\r\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \r\n                 categoryIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            Comparable key = getSectionKey(categoryIndex);\r\n            paint = lookupSectionPaint(key, true);\r\n            outlinePaint = lookupSectionOutlinePaint(key);\r\n            outlineStroke = lookupSectionOutlineStroke(key);\r\n            g2.setPaint(paint);\r\n            g2.fill(arc);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(arc);\r\n            g2.setPaint(paint);\r\n\r\n            Point2D p1 = arc.getStartPoint();\r\n\r\n            // draw the height\r\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\r\n                    (int) p1.getX(), (int) p1.getX()};\r\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \r\n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\r\n            Polygon polygon = new Polygon(xs, ys, 4);\r\n            g2.setPaint(java.awt.Color.lightGray);\r\n            g2.fill(polygon);\r\n            g2.setPaint(outlinePaint);\r\n            g2.setStroke(outlineStroke);\r\n            g2.draw(polygon);\r\n            g2.setPaint(paint);\r\n\r\n        }\r\n\r\n        g2.setPaint(Color.gray);\r\n        g2.fill(back);\r\n        g2.fill(front);\r\n\r\n        // cycle through once drawing only the sides at the back...\r\n        int cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key, true);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, false, true);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        // cycle through again drawing only the sides at the front...\r\n        cat = 0;\r\n        iterator = arcList.iterator();\r\n        while (iterator.hasNext()) {\r\n            Arc2D segment = (Arc2D) iterator.next();\r\n            if (segment != null) {\r\n                Comparable key = getSectionKey(cat);\r\n                paint = lookupSectionPaint(key);\r\n                outlinePaint = lookupSectionOutlinePaint(key);\r\n                outlineStroke = lookupSectionOutlineStroke(key);\r\n                drawSide(g2, pieArea, segment, front, back, paint, \r\n                        outlinePaint, outlineStroke, true, false);\r\n            }\r\n            cat++;\r\n        }\r\n\r\n        g2.setClip(oldClip);\r\n\r\n        // draw the sections at the top of the pie (and set up tooltips)...\r\n        Arc2D upperArc;\r\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \r\n                 sectionIndex++) {\r\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\r\n            if (arc == null) {\r\n                continue;\r\n            }\r\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\r\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \r\n                    arc.getAngleExtent(), Arc2D.PIE);\r\n            \r\n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\r\n            paint = lookupSectionPaint(currentKey, true);\r\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\r\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\r\n            g2.setPaint(paint);\r\n            g2.fill(upperArc);\r\n            g2.setStroke(outlineStroke);\r\n            g2.setPaint(outlinePaint);\r\n            g2.draw(upperArc);\r\n\r\n           // add a tooltip for the section...\r\n            if (info != null) {\r\n                EntityCollection entities \r\n                        = info.getOwner().getEntityCollection();\r\n                if (entities != null) {\r\n                    String tip = null;\r\n                    PieToolTipGenerator tipster = getToolTipGenerator();\r\n                    if (tipster != null) {\r\n                        // @mgs: using the method's return value was missing \r\n                        tip = tipster.generateToolTip(dataset, currentKey);\r\n                    }\r\n                    String url = null;\r\n                    if (getURLGenerator() != null) {\r\n                        url = getURLGenerator().generateURL(dataset, currentKey,\r\n                                getPieIndex());\r\n                    }\r\n                    PieSectionEntity entity = new PieSectionEntity(\r\n                            upperArc, dataset, getPieIndex(), sectionIndex, \r\n                            currentKey, tip, url);\r\n                    entities.add(entity);\r\n                }\r\n            }\r\n            List keys = dataset.getKeys();\r\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\r\n                    originalPlotArea.getX(), originalPlotArea.getY(), \r\n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \r\n                    - depth);\r\n            if (getSimpleLabels()) {\r\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \r\n                        linkArea, state);\r\n            }\r\n            else {\r\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \r\n                        state);\r\n            }\r\n        }\r\n\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n        drawOutline(g2, originalPlotArea);\r\n\r\n    }\r\n"],"patch1-Closure-62-kPAR-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-62-Jaid-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) {\r\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-62-Cardumen-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (sourceExcerpt != null)\n+      {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-62-jKali-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (true)\n+      {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-63-Jaid-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) {\r\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-63-jKali-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (true)\n+      {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-63-kPAR-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Closure-63-Cardumen-plausible.patch":["0","  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (sourceExcerpt != null)\n+      {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n"],"patch1-Chart-17-FixMiner-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     * \r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end) \r\n        throws CloneNotSupportedException {\r\n\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n-        if (end < start) {\n+        if ((end < start) && (this.data.size() > 0)) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\r\n        }\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item \r\n                    = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"patch1-Chart-17-kPAR-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     * \r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end) \r\n        throws CloneNotSupportedException {\r\n\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n-        if (end < start) {\n+        if ((end < start) && (this.data.size() > 0)) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\r\n        }\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item \r\n                    = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"patch1-Chart-17-Nopol-plausible.patch":["0","    /**\r\n     * Creates a new timeseries by copying a subset of the data in this time\r\n     * series.\r\n     *\r\n     * @param start  the index of the first time period to copy.\r\n     * @param end  the index of the last time period to copy.\r\n     *\r\n     * @return A series containing a copy of this times series from start until\r\n     *         end.\r\n     * \r\n     * @throws CloneNotSupportedException if there is a cloning problem.\r\n     */\r\n    public TimeSeries createCopy(int start, int end) \r\n        throws CloneNotSupportedException {\r\n\r\n        if (start < 0) {\r\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n        }\r\n        if (end < start) {\r\n-            throw new IllegalArgumentException(\"Requires start <= end.\");\n+            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) {\n+                throw new IllegalArgumentException(\"Requires start <= end.\");\n+            }\n        }\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n\r\n        copy.data = new java.util.ArrayList();\r\n        if (this.data.size() > 0) {\r\n            for (int index = start; index <= end; index++) {\r\n                TimeSeriesDataItem item \r\n                    = (TimeSeriesDataItem) this.data.get(index);\r\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n                try {\r\n                    copy.add(clone);\r\n                }\r\n                catch (SeriesException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n"],"patch1-Chart-18-SimFix-plausible.patch":["0","    /**\n     * Removes a value from the collection.\n     *\n     * @param index  the index of the item to remove (in the range \n     *     <code>0</code> to <code>getItemCount() - 1</code>).\n     *     \n     * @throws IndexOutOfBoundsException if <code>index</code> is not within\n     *     the specified range.\n     */\n    public void removeValue(int index) {\n        this.keys.remove(index);\n        this.values.remove(index);\n-        if (index < this.keys.size()) {\n+        if (index <= this.keys.size()) {\n        rebuildIndex();\n        }\n    }\n"],"patch1-Chart-18-DynaMoth-plausible.patch":["0","    /**\r\n     * Removes a column from the dataset and sends a {@link DatasetChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param columnKey  the column key.\r\n     * \r\n     * @see #removeRow(Comparable)\r\n     */\r\n    public void removeColumn(Comparable columnKey) {\r\n-        this.data.removeColumn(columnKey);\n+        if (false) {\n+            this.data.removeColumn(columnKey);\n+        }\n        fireDatasetChanged();\r\n    }\r\n"],"patch1-Closure-61-RSRepair-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        return null;\n      }\n    }\n    return res;\n  }\n"],"patch1-Closure-61-Kali-plausible.patch":["0","  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n      }\n    }\n    return res;\n  }\n"],"patch1-Chart-19-Arja-plusible.patch":["0","    /**\n     * Returns the index of the specified object, or -1 if the object is not in\n     * the list.\n     *\n     * @param object  the object.\n     *\n     * @return The index or -1.\n     */\n    protected int indexOf(Object object) {\n        for (int index = 0; index < this.size; index++) {\n            if (this.objects[index] == object) {\n                return (index);\n            }\n        }\n-        return -1;\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"Null 'object' argument.\");\n+        }\n+        return -1;\n    }\n"],"patch1-Closure-66-AVATAR-plausible.patch":["0","  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent() {\n-    int total = nullCount + unknownCount + typedCount;\n+    int total = this.noTypeCheckSection + unknownCount + typedCount;\n    if (total == 0) {\n      return 0.0;\n    } else {\n      return (100.0 * typedCount) / total;\n    }\n  }\n"],"patch1-Closure-66-TBar-plausible.patch":["0","  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent() {\n-    int total = nullCount + unknownCount + typedCount;\n+    int total = this.noTypeCheckSection + unknownCount + typedCount;\n    if (total == 0) {\n      return 0.0;\n    } else {\n      return (100.0 * typedCount) / total;\n    }\n  }\n"],"patch1-Closure-67-Kali-plausible.patch":["0","  /**\n   * Remove all properties under a given name if the property name is\n   * never referenced.\n   */\n  private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {\n    boolean changed = false;\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n        for (Symbol declaration : nameInfo.getDeclarations()) {\n          boolean canRemove = false;\n\n          if (specializationState == null) {\n            canRemove = true;\n          } else {\n            Node specializableFunction =\n              getSpecializableFunctionFromSymbol(declaration);\n\n            if (specializableFunction != null) {\n              specializationState.reportRemovedFunction(\n                  specializableFunction, null);\n              canRemove = true;\n            }\n          }\n\n-          if (canRemove) {\n+          if (false) {\n            declaration.remove();\n            changed = true;\n          }\n        }\n\n        logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n  }\n"],"patch1-Closure-67-GenProg-plausible.patch":["0","  /**\n   * Remove all properties under a given name if the property name is\n   * never referenced.\n   */\n  private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {\n    boolean changed = false;\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n-        for (Symbol declaration : nameInfo.getDeclarations()) {\n-          boolean canRemove = false;\n-\n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n-          if (canRemove) {\n-            declaration.remove();\n-            changed = true;\n-          }\n-        }\n-\n        logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n  }\n"],"patch1-Closure-67-Arja-plausible.patch":["0","  /**\n   * Remove all properties under a given name if the property name is\n   * never referenced.\n   */\n  private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {\n    boolean changed = false;\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n        for (Symbol declaration : nameInfo.getDeclarations()) {\n          boolean canRemove = false;\n\n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n          if (canRemove) {\n            declaration.remove();\n            changed = true;\n          }\n        }\n\n        logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n  }\n"],"patch1-Closure-67-RSRepair-plausible.patch":["0","  /**\n   * Remove all properties under a given name if the property name is\n   * never referenced.\n   */\n  private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {\n    boolean changed = false;\n    for (NameInfo nameInfo : allNameInfo) {\n      if (!nameInfo.isReferenced()) {\n        for (Symbol declaration : nameInfo.getDeclarations()) {\n          boolean canRemove = false;\n\n          if (specializationState == null) {\n-            canRemove = true;\n          } else {\n            Node specializableFunction =\n              getSpecializableFunctionFromSymbol(declaration);\n\n            if (specializableFunction != null) {\n              specializationState.reportRemovedFunction(\n                  specializableFunction, null);\n              canRemove = true;\n            }\n          }\n\n          if (canRemove) {\n            declaration.remove();\n            changed = true;\n          }\n        }\n\n        logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n  }\n"],"patch1-Closure-64-Kali-plausible.patch":["0","  private static boolean canFuseIntoOneStatement(Node block) {\n    // Fold only statement block. NOT scripts block.\n    if (block.getType() != Token.BLOCK) {\n      return false;\n    }\n\n    // Nothing to do here.\n    if (!block.hasChildren() || block.hasOneChild()) {\n      return false;\n    }\n\n    Node last = block.getLastChild();\n\n    for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n      if (!NodeUtil.isExpressionNode(c) && c != last) {\n-        return false;\n+        if (true)\n+            return true;\n+        return false;\n      }\n    }\n\n    // TODO(user): Support more control statement for fusion.\n    // FOR\n    switch(last.getType()) {\n      case Token.IF:\n      case Token.THROW:\n      case Token.SWITCH:\n      case Token.EXPR_RESULT:\n        return true;\n      case Token.RETURN:\n        // We don't want to add a new return value.\n        return last.hasChildren();\n      case Token.FOR:\n        return NodeUtil.isForIn(last) &&\n            // Avoid cases where we have for(var x = foo() in a) { ....\n            !NodeUtil.mayHaveSideEffects(last.getFirstChild());\n    }\n\n    return false;\n  }\n"],"patch1-Closure-68-Kali-plausible.patch":["0","  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n-          // discard any accumulated information\n-          jsdocBuilder.build(null);\n+          {\n+            if (true)\n+                return true;\n+            jsdocBuilder.build(null);\n+        }\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n"],"patch1-Closure-68-Arja-plausible.patch":["0","  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n-          parser.addParserWarning(\"msg.unexpected.eof\",\n-              stream.getLineno(), stream.getCharno());\n+          ;\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n"],"patch1-Math-72-SimFix.patch":["0","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n+        // start of generated patch\n+        if(Math.abs(yMin)<=functionValueAccuracy){\n+          setResult(min,0);\n+          return result;\n+        }\n+        // end of generated patch\n+        /* start of original code\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n+        end of original code*/\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n"],"patch1-Math-73-jGenProg-plausible.patch":["0","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        }    return solve(f, min, max);\n\n\n        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+\n\n    }\n"],"patch1-Math-73-ACS-plausible.patch":["0","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n-        // full Brent algorithm starting with provided initial guess\n+if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n"],"patch1-Math-73-Nopol-plausible.patch":["0","    /**\n     * Verifies that <code>lower < initial < upper</code>\n     * throws IllegalArgumentException if not\n     *\n     * @param lower  lower endpoint\n     * @param initial initial value\n     * @param upper upper endpoint\n     * @throws IllegalArgumentException\n     */\n    protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) {\n            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n-                    lower, initial, upper);\n+            \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+            lower, initial, upper);\n        }\n    }\n"],"patch1-Math-73-SimFix-plausible.patch":["0","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n-\n-\n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f,min,initial);\n\n    }\n"],"patch1-Math-73-Cardumen-plausible.patch":["0","    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, max, max);\n\n    }\n"],"patch1-Math-74-Arja-plausible.patch":["0","    /** {@inheritDoc} */\n    @Override\n    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0,\n                            final double t, final double[] y)\n        throws DerivativeException, IntegratorException {\n\n        final int n = y0.length;\n        sanityChecks(equations, t0, y0, t, y);\n        setEquations(equations);\n        resetEvaluations();\n        final boolean forward = t > t0;\n\n        // initialize working arrays\n        if (y != y0) {\n            System.arraycopy(y0, 0, y, 0, n);\n        }\n        final double[] yDot = new double[y0.length];\n        final double[] yTmp = new double[y0.length];\n\n        // set up two interpolators sharing the integrator arrays\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n        interpolator.reinitialize(y, forward);\n        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n        interpolatorTmp.reinitialize(yTmp, forward);\n\n        // set up integration control objects\n        for (StepHandler handler : stepHandlers) {\n            handler.reset();\n        }\n        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n\n        // compute the initial Nordsieck vector using the configured starter integrator\n        start(t0, y, t);\n        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n        interpolator.storeTime(stepStart);\n\n        double hNew = stepSize;\n        interpolator.rescale(hNew);\n\n        boolean lastStep = false;\n        while (!lastStep) {\n\n            // shift all data\n            interpolator.shift();\n\n            double error = 0;\n            for (boolean loop = true; loop;) {\n\n                stepSize = hNew;\n\n-                // predict a first estimate of the state at step end (P in the PECE sequence)\n+                lastStep = manager.stop();\n+                // predict a first estimate of the state at step end (P in the PECE sequence)\n                final double stepEnd = stepStart + stepSize;\n                interpolator.setInterpolatedTime(stepEnd);\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n\n                // evaluate a first estimate of the derivative (first E in the PECE sequence)\n                computeDerivatives(stepEnd, yTmp, yDot);\n\n                // update Nordsieck vector\n                final double[] predictedScaled = new double[y0.length];\n                for (int j = 0; j < y0.length; ++j) {\n                    predictedScaled[j] = stepSize * yDot[j];\n                }\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n\n                // apply correction (C in the PECE sequence)\n                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n\n                if (error <= 1.0) {\n\n                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n                    computeDerivatives(stepEnd, yTmp, yDot);\n\n                    // update Nordsieck vector\n                    final double[] correctedScaled = new double[y0.length];\n                    for (int j = 0; j < y0.length; ++j) {\n                        correctedScaled[j] = stepSize * yDot[j];\n                    }\n                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n\n                    // discrete events handling\n                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n-                    interpolatorTmp.storeTime(stepStart);\n+                    setMaxGrowth(10.0);\n+                    interpolatorTmp.storeTime(stepStart);\n                    interpolatorTmp.shift();\n                    interpolatorTmp.storeTime(stepEnd);\n                    if (manager.evaluateStep(interpolatorTmp)) {\n                        final double dt = manager.getEventTime() - stepStart;\n                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                            // rejecting the step would lead to a too small next step, we accept it\n                            loop = false;\n                        } else {\n                            // reject the step to match exactly the next switch time\n                            hNew = dt;\n                            interpolator.rescale(hNew);\n                        }\n                    } else {\n                        // accept the step\n                        scaled    = correctedScaled;\n                        nordsieck = nordsieckTmp;\n                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                        loop = false;\n                    }\n\n                } else {\n                    // reject the step and attempt to reduce error by stepsize control\n                    final double factor = computeStepGrowShrinkFactor(error);\n                    hNew = filterStep(stepSize * factor, forward, false);\n                    interpolator.rescale(hNew);\n                }\n\n            }\n\n            // the step has been accepted (may have been truncated)\n            final double nextStep = stepStart + stepSize;\n            System.arraycopy(yTmp, 0, y, 0, n);\n            interpolator.storeTime(nextStep);\n            manager.stepAccepted(nextStep, y);\n            lastStep = manager.stop();\n\n            // provide the step data to the step handler\n            for (StepHandler handler : stepHandlers) {\n                interpolator.setInterpolatedTime(nextStep);\n                handler.handleStep(interpolator, lastStep);\n            }\n            stepStart = nextStep;\n\n            if (!lastStep && manager.reset(stepStart, y)) {\n\n                // some events handler has triggered changes that\n                // invalidate the derivatives, we need to restart from scratch\n                start(stepStart, y, t);\n                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n\n            }\n\n            if (! lastStep) {\n                // in some rare cases we may get here with stepSize = 0, for example\n                // when an event occurs at integration start, reducing the first step\n                // to zero; we have to reset the step to some safe non zero value\n                stepSize = filterStep(stepSize, forward, true);\n\n                // stepsize control for next step\n                final double  factor     = computeStepGrowShrinkFactor(error);\n                final double  scaledH    = stepSize * factor;\n                final double  nextT      = stepStart + scaledH;\n                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                hNew = filterStep(scaledH, forward, nextIsLast);\n                interpolator.rescale(hNew);\n            }\n\n        }\n\n        final double stopTime  = stepStart;\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        return stopTime;\n\n    }\n"],"patch1-Math-78-Nopol-plausible.patch":["0","    /**\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     */\n    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n-                    delta = 0.5 * dx;\n+                    if (y0 < 1) {\n+                        delta = 0.5 * dx;\n+                    }\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n"],"patch1-Math-78-AVATAR-plausible.patch":["0","    /**\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     */\n    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n-                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n"]}