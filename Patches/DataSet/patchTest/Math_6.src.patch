diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
@@ -48,7 +48,7 @@
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
-        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
+        iterations = new Incrementor(0, new MaxIterCallback());
     }
 
     /**
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
@@ -211,15 +211,16 @@
         }
 
         PointValuePair current = null;
+        int iter = 0;
         int maxEval = getMaxEvaluations();
         while (true) {
-            incrementIterationCount();
+            ++iter;
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
-                if (checker.converged(getIterations(), previous, current)) {
+                if (checker.converged(iter, previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -273,7 +274,7 @@
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
-            if (getIterations() % n == 0 ||
+            if (iter % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
@@ -385,7 +385,6 @@
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
-            incrementIterationCount();
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
@@ -188,8 +188,9 @@
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
+        int iter = 0;
         while (true) {
-            incrementIterationCount();
+            ++iter;
 
             double fX = fVal;
             double fX2 = 0;
@@ -223,7 +224,7 @@
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
-                    stop = checker.converged(getIterations(), previous, current);
+                    stop = checker.converged(iter, previous, current);
                 }
             }
             if (stop) {
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
@@ -155,7 +155,7 @@
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
-            if (getIterations() > 0) {
+            if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -172,7 +172,7 @@
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
-            incrementIterationCount();
+			++iteration;
         }
     }
 
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
@@ -103,8 +103,9 @@
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
+        int iter = 0;
         for (boolean converged = false; !converged;) {
-            incrementIterationCount();
+            ++iter;
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -156,7 +157,7 @@
 
             // Check convergence.
             if (previous != null) {
-                converged = checker.converged(getIterations(), previous, current);
+                converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
diff -w -r -u Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
--- Math6b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
+++ Math_6.src.patch/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
@@ -319,10 +319,10 @@
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
+        int iter = 0;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
-            incrementIterationCount();
-
+            ++iter;
             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
-                        if (checker.converged(getIterations(), previous, current)) {
+                        if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
